<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Home on 仲夏叶 | 科技</title><link>https://zxye.tk/</link><description>Recent content in Home on 仲夏叶 | 科技</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 21 Dec 2020 09:39:52 +0000</lastBuildDate><atom:link href="https://zxye.tk/index.xml" rel="self" type="application/rss+xml"/><item><title>测试陷阱分类</title><link>https://zxye.tk/posts/common-system-and-software-testing-pitfalls/</link><pubDate>Mon, 21 Dec 2020 09:39:52 +0000</pubDate><guid>https://zxye.tk/posts/common-system-and-software-testing-pitfalls/</guid><description>什么是测试陷阱 # 测试陷阱是指不必要的并且可能意外导致测试不那么有效，高效或者更令人沮丧的表现的决策、思维、行为或不作为。基本上，测试陷阱是一个经常发生的搞砸测试的方式，当测试人员、管理人员、需求工程师和其他测试利益相关者犯了测试相关的错误，并由此产生意想不到的负面后果时，项目就陷入了测试陷阱。
从某种意义上说，测试陷阱的描述构成了测试反模式。然而，术语“陷阱”是专门选择，为那些粗心大意或外行的人唤起隐蔽或不易识别的陷阱的形象。与任何陷阱一样，最好是避免测试陷阱，而不是陷入陷阱后将自己和项目挖出来。
陷阱分类 # 许多测试陷阱发生在软件依赖系统和软件应用的开发或维护期间。虽然可能没有项目是如此糟糕地管理和执行，从而体验这些缺陷中的大多数，但大多数项目将遭受其中几个。同样，虽然这些测试陷阱并不保证失败，但它们必然带来需要管理的严重风险。
在测试过程中经常观察到的92种陷阱。这些缺陷分类如下：
一般测试陷阱 测试计划和进度陷阱 利益相关者的参与和承诺陷阱 管理相关测试陷阱 人员配备陷阱 测试过程陷阱 测试工具和环境陷阱 测试沟通陷阱 需求相关测试陷阱 测试类型相关陷阱 单元测试陷阱 集成测试陷阱 专业工程测试陷阱 系统测试陷阱 系统的系统测试陷阱 回归测试陷阱 共同的负面后果 # 虽然不同的测试陷阱有不同的负面后果，它们都趋向于促进以下总体最终问题：
测试有效性较低。 更多遗留缺陷躲过测试进入交付系统。 尽管付出额外的成本和时间，软件依赖系统仍然带有比预期的或者必要的更多的遗留缺陷交付并投入运行。 测试效率较低。 要达到没有陷阱能达到的相同质量，需要更多的时间和精力。 因为在开发后期花费额外的、计划外的时间和精力去发现并修复缺陷，系统交付延迟并且超出预算。 测试人员必须不可持续地长时间工作，这使他们变得筋疲力尽，因此，会犯过多的错误。 一些缺陷发现的时间比应该发现时间晚，使得缺陷更难定位和修复。 测试人员的士气受到影响。 糟糕的测试效率和有效性，使得测试人员的工作比需要的更长、更困难。 糟糕的测试有效性和由此带来的遗留缺陷的增加削弱了测试人员对工作的自豪感。 一般建议 # 除了在下文缺陷描述中提供的单个缺陷相关的建议之外，以下建议普遍适用于大多数常见的测试陷阱。
预防建议。这些一般建议可以在最初防止落入陷阱。 更新测试过程。测试人员、首席工程师和过程工程师更新测试过程以帮助项目避免落入测试陷阱，若做不到这一点，那么在已经落入陷阱时能够及时发现。 将陷阱当做风险。当相关时，陷阱应该正式在项目的风险库中识别为风险，并做相应管理。 正式要求解决方案。客户代表在适当的文档中正式要求测试陷阱的解决方案，如需求建议书、合同和工作说明书。 内部强制要求解决方案。管理人员、首席工程师（开发团队领导）或者首席测试人员（测试团队领导）在相应的文档中明确强制要求测试陷阱的解决方案，如系统工程管理计划、系统开发计划、测试计划文档或测试策略。 提供培训。首席测试人员或培训人员给相关人员（如采购人员、管理层、测试人员和质量保证人员）提供适当数量和水平的测试培训，涵盖潜在的测试陷阱和如何预防、检测及应对。 确保管理层的支持。管理人员明确说明（并提供）对测试的支持，以及避免经常发生的测试陷阱的必要性。 检测建议。以下一般建议使得识别和诊断现有的陷阱成为可能。 评估文档。评审、审查或走查测试相关的文档（例如，测试计划和开发计划的测试部分）。 确保监督。测试过程执行时提供采购方、管理层、质量保证和同行的监督。 考虑度量指标。收集、分析并向利益相关者（例如，采购方、管理人员、技术领导或首席工程师和首席测试人员）报告相关的测试指标。 应对建议。一旦检测到陷阱，以下一般建议有助于缓解。 拒绝不充分的测试文档。客户代表、管理人员和首席工程师拒绝接受测试相关的文档，指导已识别的陷阱得到解决。 拒绝交付。客户代表、管理人员和首席工程师拒绝接受被测系统或软件，直到已识别的陷阱（例如，测试环境、测试过程或测试用例）得到解决。然后对相关缺陷进行优先级排序和修复后重新运行测试。 提供培训。首席测试人员或培训人员给相关人员（如采购人员、管理人员、测试人员和质量保证人员）提供适当数量和水平的补救测试培训，涵盖以观察到的测试陷阱和如何预防、检测及应对测试陷阱。 更新过程。首席工程师、首席测试人员或过程工程师更新测试过程文档（例如，流程、指南、模板、工具手册），以最大限度地减少观察到的测试陷阱再次出现的可能性。 报告陷阱的发生。测试人员应向项目管理团队报告陷阱的发生，包括测试经理、项目经理和技术负责人。 将陷阱当做风险。如果相关时，陷阱应该正式在项目的风险库中识别为风险，并做相应管理。 摘抄自《测试反模式——有效规避常见的92种测试陷阱》（美）Donald G.</description></item><item><title>按测试员的方式思考</title><link>https://zxye.tk/posts/think-like-a-tester/</link><pubDate>Wed, 01 Jul 2020 16:32:58 +0000</pubDate><guid>https://zxye.tk/posts/think-like-a-tester/</guid><description>测试员有很多不同的背景，测试团队是多元化的集体，但是大多数人都同意：测试员的思考方式是不同的。怎么不同？有人说测试员是“消极”思维者。测试员会抱怨这种说法，认为自己喜欢征服，他们在报告坏消息时有一种特别的兴奋感。这是一种普遍观点。我们提出另一种观点。测试员并不抱怨，他们提供的是证据。测试员并不喜欢征服，他们喜欢打破产品没有问题的幻觉。测试员并不喜欢发布坏消息，他们喜欢把客户从虚假信念中解放出来。我们的观点是，按测试员的方式思考意味着实践认识论。测试运用的是认识论，不是靠傲慢或谦卑。
测试运用的是认识论 # 认识论研究如何认识所了解的东西：研究证据和推理。这是科学实践的基础。研究认识论的人有科学家、教育家和哲学家，当然还有精英级的软件测试员。学习认识论的学生研究科学、哲学和心理学，目标是了解怎样才能改进我们的思维。我们使用的术语比经典定义要宽，以便能够更多地利用批判性思维的最新成果。将认识论运用于软件测试，要问与以下类似的问题：
怎么知道软件足够好？ 如果软件并不是足够好，怎样才能知道？ 怎么知道已经完成了足够的测试？ 研究认识论有助于更好测试 # 直接与软件测试有关的认识论问题包括：
如何收集和评估证据。 如何进行有效的推论。 如何使用不同逻辑形式。 拥有合理的信念意味着什么。 形式和非形式推理之间的差别。 非形式推理的常见谬误。 自然语言的含义与模糊性。 如何做出好的决策。 研究认识论可帮助测试员设计有效的测试策略，更好地意识到自己工作中的错误，理解自己的测试能够证明什么、不能证明什么，并编写出无懈可击的测试报告。
认知心理学是测试的基础 # 如果说认识论告诉我们的是应该怎样思考，那么认知心理学告诉我们的是我们是怎样思考的。与测试有关的一些问题包括：
人的感觉和记忆可靠性。 信念从哪里来。 信念如何影响人的行为。 做出决策所使用的偏见和捷径。 如何了解并分享所知道的信息。 如何考虑复杂事情。 如何识别模式。 如何把想法和实物分类。 如何注意事物之间的差别。 记忆事件中的失真。 如何重新构建部分记忆的事件（例如不可再现的程序错误）。 研究认知心理学有助于理解影响测试员工作成绩的因素，以及影响人们解释自己工作方式的因素。测试应该使用因果关系理论进行系统推理，而不只是查看外部行为，并对照简单的预期描述进行检查。
测试需要推断，并不只是做输出与预期结果的比较 # 流行的观点认为，测试员只是执行测试用例，并对照预期结果比较执行结果。这种观点把测试看做是简单的比较活动，没有看到一些聪明人必须设计测试，并确定预期输出。想想看，测试设计人员几乎从来没有得到过应该测试什么的权威指导，更不要说应该期望什么了。可以得到的指导是要解释的主体。在现实生活中，大多数测试设计都是基于推断，或基于与测试员的推断有关的经验。不仅如此，这些推断还要随时间发生变化。像测试员那样思考，就是要掌握探索式推断的艺术。
探索式推断听起来可能像是奇怪的想法，这意味着要以一种不能事先预测的方式，通过一种思想引出另一种思想，然后再引出下一种思想。
优秀测试员会进行技术性、创造性、批判性和实用性地思考 # 各种类型的思考都要考虑测试的实施。但是我们认为需要提出四种主要思考：
技术性思考。对技术建模并理解因果关系的能力。这包括诸如相关技术事实的知识和使用工具并预测系统行为的能力。 创造性思考。产生思想并看到可能性的能力。测试员只能以能够想象得到的方式进行测试，只能寻找猜想会存在的问题。 批判性思考。评估思想并进行推断的能力。这包括在自己的思考中发现并消除错误的能力，将产品观察与质量准则关联起来的能力，以及针对特定信念或所建议的行动过程构建有说服力的测试用例的能力。 实用性思考。把想法付诸实践的能力。这种能力包括诸如运用测试工具，并使测试手段和力量与项目范围适应的技能。 总之，像测试员那样思考，会最终导致相信事物可能不像外表看起来那样。不管事物是怎样的，都可能有差别。我们发现，当测试过程以最具破坏性的方式失败时，根本原因最有可能是视野狭窄。换句话说，这不是运行了一万个测试，而本来应该运行一万零一个的问题；问题是没有想象出测试的总体大纲，没有做就算有两倍时间和资源也不会做的测试。
黑盒测试并不是基于无知的测试 # 黑盒测试意味着产品内部知识在测试中不起重要作用。大多数测试员都是黑盒测试员。为了做好黑盒测试就要了解用户，了解他们的期望和需要，了解技术，了解软件运行环境的配置，了解这个软件要与之交互的其他软件，了解软件必须管理的数据，了解开发过程，等等。黑盒测试的优势在于测试员可能与程序员的思考不同，因此有可能预测出程序员所遗漏的风险。
黑盒测试强调有关软件的用户和环境知识，这一点并不是所有人都喜欢的。我们甚至把黑盒测试描述为基于无知的测试，因为测试员自始至终都不了解软件内部代码。我们认为这反映出对测试团队角色的根本误解。我们不反对测试员了解产品的工作原理。测试员对产品的了解得越多，了解产品的方式越多，越能够更好地测试它。但是，如果测试员主要关注的是源代码，以及能够从源代码导出的测试，则测试员所做的工作也许就是程序员已经做过的，并且测试员关于这些代码的知识要少于程序员。制造问题的思路，无法解决问题。
测试员不只是游客 # 测试员对产品做的大量不是测试的事，有助于测试员对产品的了解。测试员可以浏览产品，看看产品由什么组成，怎么工作。这样做有很高的价值，但这不能算是测试。测试员和游客之间的差别在于，测试员把精力放在评估产品上，而不只是见证产品。虽然不必事先预测产品应该表现出的行为，但是试验产品能力的活动还没有成为测试，除非而且直到测试员运用某种如果问题存在就能标识的原理或过程时，这种活动才能成为测试。
探索要求大量思索 # 探索就是侦查，是没有边界的搜索。可把探索看作是在太空中遨游，需要前向、后向和侧向思索。</description></item><item><title>测试员的角色</title><link>https://zxye.tk/posts/the-role-of-the-tester/</link><pubDate>Tue, 30 Jun 2020 10:40:43 +0000</pubDate><guid>https://zxye.tk/posts/the-role-of-the-tester/</guid><description>一个角色就是一种关系。这意味着人们不能控制自己的角色，但可以协商。别人期望从测试员那里得到的可能并不合理。当测试员由于低质量的产品受到指责时（这种事时有发生），不管是谁指责，可能都存在分不清角色的问题。也许他们认为测试员的工作，就是在产品交付之前使用“质量魔术棒”敲打产品，他们也许认为测试员敲打得还不够狠。
当测试员清楚了自己的角色之后，在协商角色内容时，就有了在可能出现的任何情况下确立对自己预期的基础。但是，即使是清晰和恰当的测试角色也是一种苛求。
测试员的使命决定要做的一切 # 测试员的使命，可能要取决于自己的行业、公司、项目或团队的个性，测试项目也千差万别。把测试作为一种工艺发展的挑战，一直是建立测试实践对话所面临的困难，这种测试实践要跨越我们之间的文化和技术差异。这些差异中的很多内容，决定了测试团队的不同使命。以下任何要求都可能决定测试员的使命。
快速找出重要软件问题。 对产品质量提出总体评估。 确认产品达到某种具体标准。 帮助客户改进产品质量和可测试性。 保证测试过程能够达到可分清责任的标准。 就测试和测试员协作方式培训客户。 采用特定的方法集或遵循特定的规则集。 帮助预测和控制成本。 帮助客户改进其过程。 以最小化成本、时间或尽可能减少副作用的方式，完成自己的工作。 为满足特定客户要求，完成所有必要的工作。 如果测试员将时间和精力都投入到客户并不关心的需求上，就会冒做无关工作或生产率低的风险。测试员要与自己的经理协商使命问题，并明确使命，如果不能就使命达成一致意见，就不会有做任何工作的好基础。
**如果测试员不知道该做什么怎么办？**一种回答是评审使命。这样做可以找出自己的核心问题。如果测试员明确自己的测试使命，就可以为自己的工作辩护，并明确地确定下一步要做什么。测试员还可以用简单的描述，向其他人解释自己的角色。如果由于某种原因不能完成自己的使命，应该立即把这个问题汇报给管理层。
**如果测试员确切地知道要做什么该怎么办？**经常重新考虑自己的使命，保证自己的计划不会由于过于偏重测试问题的一个方面，而忽略其他方面。
测试员为很多客户服务 # 测试是一种服务角色，要乐于接受这种角色，因为测试员提供的服务是至关重要的。服务就意味着有客户，即要被服务的人。测试员是否成功，主要是看其是否很好地满足了客户的要求和最佳利益。这不会太难，不过测试会有很多客户，这些客户都有自己的需要，而且他们的各种需要不一定一致。
项目经理。项目经理有资格了解测试员的工作进展并施加影响。测试员根据要求向其报告工作状态。指挥项目是项目经理的特权。测试员的责任就是告诉项目经理自己能做什么，不能做什么，有关项目的决策和条件会对测试产生什么影响。 程序员。通过尽可能迅速地提供好的错误报告，使得程序员的工作更容易一些。努力提高自己的技能并了解产品，以免用错误的或用毫无意义的报告浪费程序员的时间。如果测试员可以做到这一点，就可以赢得更多的信任，而这种信任又可以转化为支持和影响。 技术文档编写员。与测试员一样，负责编写文档和在线帮助的技术文档编写员也不能得到产品的完整信息。测试员可以帮助他们理解产品到底怎样发挥效能，并为其指出文档中的错误。技术文档编写员也会帮助测试员。当技术文档编写员研究产品，以及必须阅读文档的用户会怎样使用产品时，会了解到一些测试员不知道的信息。如果测试员与技术文档编写员有很好的关系，编写员就会告诉测试员有关产品的新特性、新用法、测试计划中的漏洞和他们所发现的软件问题。这些问题中的一部分永远也不会被报告，除非某个文档编写员知道哪个测试员关心这些程序问题。 技术支持员。遗留在产品中的任何问题都会为技术支持员带来负担。测试员通过告诉技术支持员可能会给用户带来麻烦的产品问题，向其提供服务。如果测试员在开发期间与技术支持员一起工作，有时技术支持员会帮助测试员找出应该更正的软件问题。测试员也应该通过研究发现的难题，为技术支持员提供帮助。通过这种方式，能够把测试员与技术支持员拉得更近，进而与客户也更近了。 市场开发员。市场开发员需要了解产品中任何与产品应该提供给客户的关键利益不一致的地方。对于程序员来说是很小的程序问题，对于市场开发员来说可能会是至关重要的问题。他们也许能意识到这种程序问题会使客户较难完成某种重要任务。此外，通过评审市场开发计划文档或描述，测试员可以帮助市场开发员对产品能力有更精确的认识。 管理层和项目相关人员。测试员服务于公司业务，这也是为什么测试员必须小心，不要像个质量狂，而不是通情达理的人的原因。特别是到了项目要结束的时候，测试员要以兼顾公司短期和长期利益的方式完成自己的职责。要以明确、简洁的词汇编写测试状态报告，一遍执行经理能够感到有做出决策的依据。 用户。在测试员的心中，要想着将要使用该产品的人。当然，用户的满意是项目的最高利益。但是还要考虑满足主要用户对项目团队的特殊要求。 以上列出的各条没有什么特别顺序，不过在实际项目中可能有一定顺序，因此要认真研究，找出对项目最重要的人，找出要服务的人。这是做好测试工作的第一步。
当心“完备的”测试 # 测试员的任务就是找出并报告重要的程序问题，但是不会发现所有的程序问题。为了发现全部程序错误，测试员必须检查所有可能有问题的地方，要在所有可能发生的不同条件下观察这些地方，还需要一种十分可靠的方法，当所有类型的程序错误发生时，都能够识别出来。如果测试员认为自己能够做到这些，那么要么产品非常简单，要么测试员的想象力太差。
知道并承认自己不能做所有的事之后，测试员必须选择如何使用自己的时间。
有一些测试员承认自己不知道是否发现了产品中的全部问题，但仍然不准确地讨论结束测试的含义。”对这个产品我需要测试5天“可以解释为，他可以在5天之内对产品进行完备的测试，也可能意味着他会在5天内发现所有问题。完备性常常是隐含地表示出来的，而不是明说出来的。不管是哪种情况，这都是必须小心对待的概念。请考虑完备测试可能的含义：
完全发现了产品中的每个问题。 完全检查了产品的每个部分。 完成了自认为是有用和经济的测试。 尽自己所能，完全达到了项目团队制定的目标。 完成了约定的测试。 完成了在一定条件下人所能够测试的所有内容。 完成了自己所承担的测试部分，不考虑其他人的工作。 完成了对产品很广、但是不深的测试。 完成了对产品的一种测试。 用完了分配给测试的时间。 如果测试员小心地澄清自己的意思，不要有“完备”、“完成”、“结束”等含义，则可能会安全，由于有些工作没有做而受到的责备可能更少，在收到责备时可以更好地为自己辩护。请注意，”完备“的定义并不是在项目一开始就能够最终确定的，随着测试项目的进展，随着新测试任务的突然出现，需要重新考虑。
为了解决在完备性上的普遍沟通问题，可让客户想想了解测试过程。总结自己实施的测试，以及为什么值得实施这些测试，并告诉客户自己没有做的其他值得做的测试，以及为什么没有做这些测试。
迅速找出重要程序问题 # 测试员的使命很可能包括找出重要的（与无意义相反）程序问题，而且要迅速找出。如果是这样，那么这对测试员所执行的测试意味着什么呢？
首先测试经过变更的部分，然后测试没有变化的部分。修改和更新都意味着新的风险。 首先测试核心功能，然后测试辅助功能，测试产品所完成的关键和常用功能，测试完成产品基本任务的功能。 首先测试能力，然后测试可靠性。先测试每个功能是否完全能用，然后再深入检查任何一个功能在很多不同条件下表现如何。 首先测试常见情况，然后测试少见情况。使用常用的数据和使用场景。 首先测试场景威胁，然后测试罕见威胁。用最有可能出现的压力和错误情况进行测试。 首先测试影响大的问题，然后测试影响小的问题。测试在出现失效的情况下会产生大量破坏的产品部件。 首先测试最需要的部分，然后测试没有要求的部分。测试对团队其他人有重要意义的任何不等的任何问题。 测试员如果对产品、产品必须与之交互的软件和硬件以及将使用的人越了解，越有可能更快地找出重要问题。应好好研究这些方面的内容。</description></item><item><title>如何编写好的测试用例</title><link>https://zxye.tk/posts/how-to-write-good-test-cases/</link><pubDate>Tue, 23 Jun 2020 22:51:59 +0000</pubDate><guid>https://zxye.tk/posts/how-to-write-good-test-cases/</guid><description>什么是测试用例 # 测试用例（Test Case）是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。是将软件测试的行为活动做一个科学化的组织归纳，目的是能够将软件测试的行为转化成可管理的模式。同时测试用例也是将测试具体量化的方法之一，不同类别的软件，测试用例是不同的。
通俗的讲：就是把整个测试流程的操作步骤用按照一定的格式用文字描述出来。
为什么要写测试用例 # *测试*用例是测试执行的指导；是测试执行的实体，是测试方法、测试质量、测试覆盖率的重要依据和表现形式；是团队内部交流以及交叉测试的依据，便于测试工作的跟踪管理，包括测试执行的进度跟踪，测试质量的跟踪，以及测试人员的工作量的跟踪和考核；在测试执行工作开展前完成测试用例的编写，可以避免测试工作开展的盲目性；测试用例是说服用户相信产品质量的最佳依据，同时也可以提供给客户作为项目验收的依据。
1、 理清思路，避免遗漏测试点
理清思路是我们认为最重要的一点，有的系统本来就是一个大而复杂的项目，我们需要把项目功能细分，根据每一个功能通过编写用例的方式来整理我们测试系统的思路，避免遗漏掉要测试的功能点。
2、 跟踪测试进度进展
通过编写测试用例，执行测试用例，我们可以很清楚的知道我们的测试进度，方便跟踪我们的测试进度。
3、 回归测试
首先我们的系统不是测一遍就完了的，我们需要在开发环境上测试，测试环境上还要进行回归，其次还有可能涉及到合并测试，而且也有可能会有不同的人在不同的阶段进行测试，那么我们就需要测试用例来规范和指导我们的测试行为。
4、 历史参考
在我们所做项目的各个版本中，也许会有很多功能是相同或相近的，我们对这类功能设计了测试用例，便于以后我们遇到类似功能的时候可以做参考依据。
另外如果产品发布后出现了发布缺陷，测试用例也是分析发布后缺陷的依据之一。
一、编写用例的重要性
1.深入了解需求的过程，一个项目立项开始，测试就开始介入，我们从产品的PRD文档、用户交互图，视觉图等相关文档去熟悉产品的各个模块，各个业务流程。或者在产品规划和设计阶段，测试开始熟悉产品。而编写用例的过程中，会充分的思考产品需求的细枝末节，需求的不合理、有矛盾、不明确的地方，还能对产品提出更好的建议，监督产品对需求做出更加详细的设计。整个过程是对需求深入了解的过程，产品的整个印象都在测试脑海里。
**2.测试执行的指导，**用例编写是把产品需求转换为一种可操作步骤的行为，方便以后作为测试的标准，有步骤有计划的进行测试。如果没有这个标准，会使你的测试过程无计划，无目标，变成一个放任主流的状态，完全没有受控性。这样的产品质量保证显然是空谈。
**3.规划测试数据的准备，**在我们的实践中测试数据是与测试用例分离的。按照测试用例配套准备一组或若干组测试原始数据，以及标准测试结果。尤其象测试报表之类数据集的正确性，按照测试用例规划准备测试数据是十分必须的。除正常数据之外，还必须根据测试用例设计大量边缘数据和错误数据
**4.反应测试进度，**测试人员开始按照测试用例的描述测试，每过完一个用例标记完成；这样测试也知道自己做过哪些操作，避免没有目的随机测试。并且通过测试用例的执行条数，大致了解该模块的测试进度。
**5.举一反三发现潜藏缺陷，**测试人员在执行用例的过程中往往会突然发现当初设计的用例步骤中，还可以做这样一个操作，于是发现了bug，这又体现了测试用例的作用， 帮助发现拓展测试范围，扩大测试覆盖面，发现软件中潜藏的缺陷。
6.分析缺陷的标准 通过收集缺陷，对比测试用例和缺陷数据库，分析确证是漏测还是缺陷复现。漏测反映了测试用例的不完善，应立即补充相应测试用例，最终达到逐步完善软件质量。而已有相应测试用例，则反映实施测试或变更处理存在问题。
好用例的标准 # https://zhuanlan.zhihu.com/p/94993557 https://zhuanlan.zhihu.com/p/24308453 https://blog.csdn.net/qq_28967695/article/details/73609070 https://yq.aliyun.com/articles/130204 https://zhuanlan.zhihu.com/p/74623927 https://blog.csdn.net/deyili/article/details/6640259 https://zhuanlan.zhihu.com/p/89633142 https://www.jianshu.com/p/d8931aa92b10 好用例的标准
是否可以发现Bug 设计测试用例的目的就是为了发现bug，如果bug都发现不了，怎么能称得上是一个好的测试用例呢？
是否够高效 一个好的测试用例应该不止测试一个测试点，从而减少需要的用例总量。但也不能包含太多不想关的测试点，否则你这个用例就没法测试了，并且给开发的debug造成困难。
是否够经济 这个测试用例执行起来是否容易，分析和debug是否要花太多代价，都是值得考虑的，毕竟咱也要站在组织的角度来看待测试这个事，公司是为了盈利而做这些事，而不是为了做测试而测试。
是否有足够的扩展性 主要是考察测试用例在维护时是否要花费很大的代价。
1、用例覆盖程度
　毫无疑问，这一点应该是最重要的，无需多说，覆盖率最大化是一套测试用例的最重要评价标准，如果漏测就杯具了。
2、用例是否已经达到工作量最小化
　在满足用例覆盖程度最大化的前提下，应该尽量减小执行用例所需要的工作量。这些方面的方法有不少，如条件覆盖，分支覆盖，正交覆盖等方法。面对不同的测试对象，也有不同的方法来保证：对于网页背后的php逻辑，可以通过在网页上测试后，用一些工具比如xdebug来统计代码覆盖率；对于向外提供接口的server，采用的方式就是分析在外面暴露的接口设计用例，大致的通过接口参数来估计一下分支判断的情况。
3、用例的分类以及描述是否足够清晰
　用例的分类，在这里是指相同类型的用例是否放在一起了。例如：接口类的用例，参数的取值范围是1-3，但是现在却传入4；数据类用例，状态机现在位于状态2，却要求状态跳转到无法到达的4；逻辑类用例，正常功能的产出等。将相同类型的用例放在一起，有助于理清思路，清楚了解用例设计是否完备。
　用例的描述，是指描述的清晰程度是否能够形成文档。例如上面参数取值范围的例子，用例这样写：“传入错误的值”或者“传入非1-3的值”，明显没有写成“传入值4”有效。这与写程序一样，总是写闭区间的范围而不是开区间。</description></item><item><title>结构化思维方法</title><link>https://zxye.tk/posts/structure-thinking-methods/</link><pubDate>Sun, 05 Jan 2020 15:07:09 +0000</pubDate><guid>https://zxye.tk/posts/structure-thinking-methods/</guid><description>思维混乱，是因为大脑没有结构 # 请你花10秒钟的时间，记住以下的20个数字：
好，我们再来试一组数字，还是花10秒钟来记住它：
其实这2组的20个数字是一样的，但是不是觉得第二组一下子就记住了？
为什么会这样？ # 因为第二组数据更符合我们大脑的使用习惯，数字与数字之间有清晰的逻辑和结构。
我们大脑处理信息有2个规律：
太多的信息记不住 喜欢有规律的信息 可你有没有遇到过这样的情况：有人口若悬河的和你讲了半天，他说的每个字你都听得懂，然而组合在一起，你并不知道他想说什么，内容没有逻辑，语句没有重点，就像刚才那一串杂乱的数字&amp;hellip;
听他说话时间一长，你甚至开始头疼，变得焦躁，心里骂到：“你TM到底想说什么&amp;hellip;？”
你别觉得听着难受，讲的人，他自己也许更难受！
明明心里有很多想法，甚至做了上百页的PPT，但就是讲不清楚….为什么会这样？
因为思维没有结构 # 我们思考问题的时候，脑子里的想法会不断地涌现出来，看似有很多，却杂乱无章，就像是衣橱里的一堆没有整理的衣服，彼此缠绕，互相堆砌在一起。
当有人问你，你能说说你有哪些衣服吗？
“嗯&amp;hellip;.我有很多衣服（想法）&amp;hellip;”
能详细点说吗？ # “我有一条蓝裤子，一条橘黄色裙子，一件白衬衫，还有件灰白条纹衬衫，一条牛仔裤，一条蓝色竖条纹的裤子，还有顶黑色的帽子，哦对了，还有一条蓝色裤子（这个刚才好像说过了)…”
￥#%@#￥%@… 你到底有些啥？
“我刚才说的都是我有的啊…”
语言是思维的传声筒
如果你的思维没有经过整理，就会像这堆乱糟糟的衣服，你拥有他们，却无法理解他们！
自己看着难受，别人听着难懂！
那怎么办？如何让思维变得既全面又有序呢？
你需要结构化思维 # 所谓结构化思维，就像是把衣橱里的这些衣服，分门别类的整理好。
比如按季节分类，按穿着场合分类，按服装风格分类等等..
这时候，别人再问你：你有些什么衣服呢？
你回答：我一共有208件装备，分为：
夏季、春秋季、冬季三大类； 每个季节的衣服又分为工作装、休闲装、宴会装、运动装四大系列； 其中，休闲装里有田园、淑女、简约三种风格； 每种风格的衣服，拥有深色、浅色各3套搭配； 另外配了4双运动鞋，5双皮鞋，6双休闲鞋，7个包包，8顶帽子来应对不同需要.. 是不是听着清楚多了？
并且，当你需要使用这些整理好的衣服时，也会变得很方便。
比如，今天你想要和男朋友晚上去一个party，那么你不需要再从所有的衣服里翻来覆去的寻找，一件件试穿&amp;hellip;
而是直接在已经分类好的衣橱中，找到宴会装区域，从里面拿起一套适合的即可。
把你的想法和思维内容，像整理衣服一样，分门别类的安放好，组成一个结构分明的整体，方便日后的理解、存储、使用。这个，就称之为「结构化思维」
学会结构化的思维，有什么好处？ # 如果你能够习惯用结构化的方式进行思考，你的思维能力，沟通能力，学习能力都将获得大幅度的提升：
比如，公司的线下门店，生意突然下滑，怎么办？
如果你不会结构化思维，你可能会这样说&amp;hellip;
思路清晰，考虑周全。
再比如，你们公司近期要举办一场大型的相亲活动，你是项目的负责人，目前正在召开项目工作会议，老板请你介绍一下本次活动目前的安排：
如果你不会结构化思维，你可能会这样表达&amp;hellip;
是不是感觉整个表达逻辑非常的有序，层次分明？
除了表达和思考，结构化的能力还能帮助我们提高学习的效率，比如我问你：过去一年，你都学了些啥呢？
如果你不会结构化思维，你可能会这样回答&amp;hellip;
怎么样？是不是感觉很不一样呢？
好，说了那么多结构化思维的好处，那么，我们应该如何才能拥有这种能力呢？
接下来，我就带你从最基本的地方开始说起，帮助你快速学会结构化思维。</description></item><item><title>结构化思维</title><link>https://zxye.tk/posts/structure-thinking/</link><pubDate>Sat, 04 Jan 2020 20:50:13 +0000</pubDate><guid>https://zxye.tk/posts/structure-thinking/</guid><description>技术人具备“结构化思维”意味着什么? # 作者:张建飞 高级技术专家
在日常工作中，我们时常会碰到这样的情况，有的人讲事情逻辑非常混乱，罗列了很多事项，却把握不到重点，无法把一件事情说清楚。这种思维混乱是典型的缺少结构化思维的表现。结构化思维非常重要，不仅仅体现在表达上，也体现在在我们分析问题的过程中。具备结构化思维，才能将问题分析地更全面、更深刻。
什么是结构化思维? # 那么到底是什么是结构化思维呢?简单来说，结构化思维的定义就是:逻辑 + 套路。
表达要有逻辑 # 所谓逻辑是指我们的结构之间必须是有逻辑关系的。例如，你说话的时候用“第一、第二、第三”这个逻辑顺序是合理的，但是，用“第一，第二，第四”就会显得很奇怪。当然，即使你用了”一、二、三”，也不一定就意味着你的内容有逻辑关系。
想让内容有逻辑关系，我们要学会四种组织思想的逻辑关系:
1)演绎(因果)顺序:“大前提、小前提、结论”的演绎推理方式就是演绎顺序。
比如，经典三段论:所有人都要死，苏格拉底是人，苏格拉底要死。
2)时间(步骤)顺序:“第一、第二、第三”，“首先、然后、再者”等，很多的时间顺序同时也是因果顺序。
3)空间(结构)顺序:“前端、后端、数据”，“波士顿、纽约、华盛顿”，化整为零(将整体分解为部分)等都是空间顺序。
4)程度(重要性)顺序:比如“最重要、次重要、不重要”等。 实际上，所有的逻辑关系都在这四种顺序之内。只要我们的思想和表达在这四种逻辑顺序之内，就是有逻辑的，否则就会显得没有逻辑性。
做事要有套路 # 套路是指我们解决问题的方法论，这个也非常重要。比如，5W2H 分析法就是一个非常好的，可以帮助我们分析问题的一个”套路”。试想一下，面对任何一个问题，你都能从 Why、Who、When、Where、What、How 和 How much(如下图所示)，七个方面去思考。是不是比不知道这个方法论的人，用点状的思考，5W2H 分析法就全面得多。
图片来源:https://www.toutiao.com/i6619057728725729800/
例如，我们在对问题域进行分析和领域知识提炼的时候，就可以用上 5W2H。 5W2H 模型给出了具有指导意义的约束，要求我们提炼的领域知识必须具备模型的六个要素。这就好比两位侃侃而谈的交谈者，因为有了确定的主题与话题边界，一场本来是漫无目的野鹤闲云似的闲聊就变成了一次深度交流的专题高端对话。
逻辑是一种能力，而套路是方法论，是经验。逻辑是道的东西，而方法论是术的东西。二者都很重要，只有熟练的掌握二者我们才能更好的进行结构化思考。
如何进行结构化思考? # 逻辑性和方法论是结构化思维的底层，那么如何进行结构化思考呢?这也是有方法论的，总的来说是有两个步骤，首先是“建立中心”，然后再进行“分解”。
建立中心 # 建立中心也就是要定义清楚要解决的问题，要明确目标。是我们结构的顶层节点，也是一种以终为始的思考方式。也就是说，我们首先要搞清楚 why，然后再进行 how。
★ 建立中心有两种方式:
自上而下:适用于问题比较明确的情况，我们只需要找到问题的核心要素即可，然后进行展开即可。
自下而上:对于问题不够明确的情况，我们需要对多种杂乱的内容，进行分类、剪枝、归纳汇总成一个中心。 建立中心通常不会是一次成型的，随着对问题理解的变化，对中心的抽象也会进行相应的调整。不同的抽象层次其面对的问题宽度是不一样的。具体要用哪个层次的抽象作为“中心”，要视具体情况而定。
比如面对“系统 bug 多”的问题，向上抽象是“提升代码质量”，向下抽象是 “加强测试”，都可以作为中心，选择哪个为中心取决于你当前要解决的问题是什么。
结构化分解 # 确定完中心之后，我们需要构建一个结构，使用结构化的思维对问题进行分解。 分解的策略就是我们上文提到的四种逻辑顺序，即演绎顺序、时间顺序、空间顺序和程度顺序。</description></item><item><title>用例设计方法简介</title><link>https://zxye.tk/posts/test-case-design-intro/</link><pubDate>Wed, 25 Dec 2019 16:04:52 +0000</pubDate><guid>https://zxye.tk/posts/test-case-design-intro/</guid><description>黑盒测试用例设计方法 # 黑盒测试用例设计方法包括等价类划分法、边界值分析法、错误推导法、因果图法、判定表驱动法、正交试验设计法、功能图法、场景图法等。
（一）等价类划分法 # 定义：等价类划分法是把所有可能输入的数据，即程序的输入域划分为若干部分（子集），然后从每一个子集中选取少数具有代表性的数据作为测试用例。等价类方法是一种重要的、常用的黑盒测试用例设计方法。
等价类是指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的，并合理地假定：测试某等价类的代表值就等于对这一类其他值的测试，因此，可以把全部输入数据合理划分为若干等价类，在每一个等价类中取一个数据作为测试的输入条件就可以用少量代表性的测试数据取得较好的测试结果。等价类划分有两种不同的情况：有效等价类和无效等价类。
有效等价类，是指对于程序的规格说明来说是合理的、有意义的输入数据构成的集合。利用有效等价类可检验程序是否实现了规格说明所规定的功能和性能。
无效等价类，指对程序的规格说明是不合理的或无意义的输入数据所构成的集合。对于具体的问题，无效等价类至少应有一个，也可能多个。
划分标准： # 完备测试、避免冗余 划分等价类重要的是：集合的划分、划分为互不相交的一组子集，而子集的并是整个集合 并是整个集合：备性 子集互不相交：保证一种形式的无冗余性 同一类中标识（选择）一个测试用例，同一等价类中，往往处理相同，相同处理映射到“相同的执行路径”。 划分方法： # 在输入条件规定了取值范围或值的个数的情况下，则可以确立一个有效等价类和两个无效等价类。如：输入值是学生成绩，范围是0~100
在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可确立一个有效等价类和一个无效等价类：
在输入条件是一个布尔量的情况下，可确定一个有效等价类和一个无效等价类。布尔量是一个二值枚举类型, 一个布尔量具有两种状态: true 和 false 。
在规定了输入数据的一组值（假定n个），并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和一个无效等价类。
例：输入条件说明学历可为：专科、本科、硕士、博士四种之一，则分别取这四种的四个值作为四个有效等价类，另外把四种学历之外的任何学历作为无效等价类。
在规定了输入数据必须遵守的规则情况下，可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）；
在确知已划分的等价类中各元素在程序处理中的方式不同的情况下，则应在将该等价类进一步的划分为更小的等价类。
转化为测试用例： # 在确立了等价类后，可建立等价类表，列出所有划分出的等价类输入条件：有效等价类、无效等价类，然后从划分出的等价类中按以下三个原则设计测试用例：
为每一个等价类规定一个唯一的编号； 设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖地有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止； 设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止。 实例1：三角形问题 # 某程序规定：“输入三个整数a、b、c分别作为三边的边长构成三角形。通过程序判定所构成的三角形的类型，当此三角形为一般三角形、等腰三角形、等边三角形时，分别做计算。。。”用等价类划分方法为该程序进行测试用例设计。
分析题目中给出和隐含的对输入条件的要求：
（1）整数 （2）三个数（3）非零数（4）正数
（5）两边之和大于第三边（6）等腰 （7）等边
如果a、b、c满足条件（1）~（4），则输出下列四种情况之一：
如果不满足条件（5），则程序输出为“非三角形” 如果三条边相等即满足条件（7），则程序输出为“等边三角形” 如果只有两条边相等，及满足条件（6），则程序输出为“等腰三角形” 如果三条边都不相等，则程序输出为“一般三角形” 列出等价类表并编号 # 覆盖有效等价类的测试用例：</description></item><item><title>Android随机测试工具Monkey简介</title><link>https://zxye.tk/posts/android-adb-shell-monkey-abc/</link><pubDate>Mon, 23 Dec 2019 16:11:14 +0000</pubDate><guid>https://zxye.tk/posts/android-adb-shell-monkey-abc/</guid><description>Monkey 是一个在模拟器或设备上运行的程序，可生成伪随机用户事件（例如点击、轻触或手势）流以及很多系统级事件。您可以使用 Monkey 以随机且可重复的方式对正在开发的应用进行压力测试。
概览 # Monkey 是一个命令行工具，可以在任何模拟器实例或设备上运行。它会将伪随机用户事件流发送到系统中，从而在您正在开发的应用软件上进行压力测试。
Monkey 包含许多选项，主要分为以下四个类别：
基本配置选项，例如设置要尝试的事件数。 操作限制条件，例如将测试对象限制为单个软件包。 事件类型和频率。 调试选项。 Monkey 在运行时会生成事件并将其发送到系统。它还会监视被测系统并查找三种特殊情况：
如果您已将 Monkey 限制为在一个或多个特定软件包中运行，它会监视转到任何其他软件包的尝试并阻止它们。 如果应用崩溃或收到任何未处理的异常，Monkey 会停止并报告错误。 如果应用生成“应用无响应”错误，Monkey 会停止并报告错误。 根据您选择的详细程度级别，您还将看到有关 Monkey 进度和所生成事件的报告。
Monkey 的基本用法 # 您可以使用开发计算机上的命令行启动 Monkey，也可以通过脚本启动。由于 Monkey 在模拟器/设备环境中运行，因此您必须从该环境中通过 shell 启动它。为此，您可以在每个命令前面加上 adb shell，或者直接进入 shell 并输入 Monkey 命令。
基本语法如下：
$ adb shell monkey [options] &amp;lt;event-count&amp;gt; 如果未指定任何选项，Monkey 将以静默（非详细）模式启动，并将事件发送到目标上安装的任何（及所有）软件包。下面是一个更典型的命令行，它会启动您的应用并向其发送 500 个伪随机事件：
$ adb shell monkey -p your.package.name -v 500 命令选项参考 # 下表列出了您可以在 Monkey 命令行中添加的所有选项。</description></item><item><title>自动化测试入门级用例编写建议</title><link>https://zxye.tk/posts/autotest-abc-and-case-suggest/</link><pubDate>Wed, 18 Dec 2019 14:51:34 +0000</pubDate><guid>https://zxye.tk/posts/autotest-abc-and-case-suggest/</guid><description>自动化测试 # 一般是指软件测试的自动化，软件测试就是在预设条件下运行系统或应用程序，评估运行结果，预先条件应包括正常条件和异常条件。自动化测试是把以人为驱动的测试行为转化为机器执行的一种过程。
进阶图谱 # 新手入门 # 任职要求 # 有良好的沟通和协调能力，理解能力、逻辑分析能力，有责任心和团队合作精神； 熟练掌握javascript工具； 掌握一种以上自动化测试工具； 熟悉掌握计算机语言，如：C/C++/C#，Java，JS等。 任职标准 # 参与日常项目测试，编写测试用例，执行测试，确保项目质量和进度； 追踪项目Bug修改情况，注意寻求解决问题方法； 编写自动化测试脚本，主动寻求任何提高测试效率的方法； 主动提供反馈和优化建议，持续改进项目质量； 参与项目性能测试和安全测试； 熟悉web端和移动端的自动化测试流程、方法； 熟练使用常用的自动化测试工具,具备独立完成并维护测试脚本的编写能力。 初级选手 # 任职要求 # 熟悉Java，Eclipse, IDEA等开发环境； 了解一种以上自动化测试框架如Selenium/Appium/Uiautomator/Uiautomation/Robotium。 任职标准 # 根据测试用例创建并提交测试脚本； 关注测试结果并及时更新测试脚本； 维护并更新测试框架及工具； 维护CI和测试环境。 高级专家 # 任职要求 # 移动客户端产品测试工作经验（Android，iOS）； 熟悉常用各种测试工具，如：用例管理工具，bug管理工具，性能工具； 熟悉SQL语言以及MySQL数据库操作； 掌握Java编程； 有基于Selenium的自动化测试框架开发经验； 有性能测试经验，掌握Loadrunner工具； 有接口自动化脚本开发经验； 熟练使用linux，能独立完成各类搭建部署工作； 熟悉Oracle或MySQL等数据库； 善于发现、分析和总结问题，富有团队精神，责任心强，能适应高强度的工作。 任职标准 # 负责移动客户端应用的功能完整性测试，界面用户体验测试，兼容性测试； 参与产品分析过程，根据产品需求创建和维护测试用例，能够制定测试计划； 分析并预警项目风险，规范测试流程和相关制度； 完成测试用例的编写，用例执行，测试报告汇总等日常测试工作，确保产品发布质量。 资深达人 # 任职要求 # 熟悉WEB技术，如DOM,HTML/Css,JavaScript； 熟练使用至少一种语言,如：Java、Python、PHP、Perl、Ruby等； 熟悉Oracle/MySQL/SQL Server等至少一种数据库管理系统，能够熟练编写SQL语句； 熟悉常见的性能测试工具或自动化测试工具,并具备测试数据的分析能力； 熟悉基于 Linux 的开发环境，可以自己开发搭建自动化测试工具有效管理自动化脚本的开发和维护工作； 能根据业务特点选型合适的框架，有工具开发或框架经验。 任职标准 # 能够负责项目的测试工作，依据公司制定的测试工作规范，组织并保证产品质量以及测试工作的顺利进行； 参加并完成项目的测试工作，包括功能测试和自动化测试，其主要会更多职责担当应用系统的自动化测试工作； 开发自动化测试框架，提高测试用例的自动化程度； 研究和实施先进的测试框架和测试方法，提高测试效率； 制定自动化测试计划，撰写测试文档和测试报告，保证测试质量； 协调开发与运维进度，推动项目上线； 对测试工程师进行自动化测试方面的培训岗位要求。 提高ROI # 想要提高ROI（Return On Investment，投资回报率），我们必须从两方面入手：</description></item><item><title>计算机软件测试规范</title><link>https://zxye.tk/posts/specification-of-computer-software-testing/</link><pubDate>Tue, 03 Dec 2019 22:40:33 +0000</pubDate><guid>https://zxye.tk/posts/specification-of-computer-software-testing/</guid><description>标准号：GB/T 15532-2008 计算机软件测试规范
关联标准
GB/T 8566 信息技术 软件生存周期过程
GB/T 9386 计算机软件测试文档编制规范
GB/T 11457 信息技术 软件工程术语
GB/T 16260.1 软件工程 产品质量 第一部分：质量模型
GB/T 18492 信息技术 系统及软件完整性级别
GB/T 20158 信息技术 软件生存周期过程 配置管理
测试目的 # 计算机软件的测试目的是：
验证软件是否满足软件开发合同或项目开发计划、系统/子系统设计文档、软件需求规格说明、软件设计说明和软件产品说明等规定的软件质量要求； 通过测试，发现软件缺陷； 为软件产品的质量测量和评价提供依据。 测试类别 # 根据 GB/T 8566 的要求，本标准对如下测试类别做详细描述：
单元测试； 集成测试； 配置项测试（也称软件合格性测试或确认测试）； 系统测试； 验收测试。 可根据软件的模型、类型、完整性级别选择执行测试类型。
回归测试可出现在上述每个测试类别中，并贯穿于整个软件生存周期，故单独分类进行描述。
测试过程 # 概述 # 软件测试过程一般包括四项活动，按顺序分别是：测试侧或、测试设计、测试执行、测试总结。
测试策划 # 测试策划主要是进行测试需求分析。即确定需要测试的内容或质量特性；确定测试的充分性要求；踢出测试的基本方法；确定测试的资源和技术需求；进行风险分析与评估；制定测试计划（含资源计划和进度计划）。有关测试计划的内容和要求见 GB/T 9386 。</description></item><item><title>麦肯锡教我的思考武器</title><link>https://zxye.tk/posts/issue-driven/</link><pubDate>Sat, 28 Sep 2019 22:48:58 +0000</pubDate><guid>https://zxye.tk/posts/issue-driven/</guid><description>议题驱动 # 《麦肯锡教我的思考武器——从逻辑思考到真正解决问题》
思考，不要用蛮力！工作，不只靠体力！
从议题出发，创造有价值的工作
解决问题之前，要先查明问题 提升答案的质量并不够，提升议题的质量更重要 不是知道越多越聪明，而是知道太多会变笨 与其快速做完每一件事，不如删减要做的事 与其计较数字多寡，不如计较到底有没有答案 价值矩阵 # 以价值为导向的组织里只谈功劳不谈苦劳 对于议题度低的问题，无论多么努力拼命地挤出答案，终究也不能提高其价值，只是白忙而已 只靠努力与蛮力，不可能达到右上方有价值的工作区域</description></item><item><title>CentOS 安装 Kubernetes 集群</title><link>https://zxye.tk/posts/kubernetes-cluster-using-centos/</link><pubDate>Fri, 02 Aug 2019 20:33:54 +0000</pubDate><guid>https://zxye.tk/posts/kubernetes-cluster-using-centos/</guid><description>准备工作 # 一台或多台运行着下列系统的机器: CentOS 7 RHEL 7 每台机器 2 GB 或更多的 RAM (如果少于这个数字将会影响您应用的运行内存) 2 CPU 核心或更多 集群中的所有机器的网络彼此均能相互连接(公网和内网都可以) 节点之中不可以有重复的主机名，MAC 地址，product_uuid。更多详细信息请参见这里 。 开启主机上的一些特定端口. 更多详细信息请参见这里。 禁用 Swap 交换分区。为了保证 kubelet 正确运行，您 必须 禁用交换分区。 确保每个节点上 MAC 地址和 product_uuid 的唯一性。 # 您可以使用下列命令获取网络接口的 MAC 地址：ip link 或是 ifconfig -a 下列命令可以用来获取 product_uuid sudo cat /sys/class/dmi/id/product_uuid 一般来讲，硬件设备会拥有独一无二的地址，但是有些虚拟机可能会雷同。Kubernetes 使用这些值来唯一确定集群中的节点。如果这些值在集群中不唯一，可能会导致安装失败。
检查网络适配器 # 如果您有一个以上的网络适配器，同时您的 Kubernetes 组件通过默认路由不可达，我们建议您预先添加 IP 路由规则，这样 Kubernetes 集群就可以通过对应的适配器完成连接。
检查所需端口 # Master 节点 # 规则 方向 端口范围 作用 使用者 TCP Inbound 6443* Kubernetes API server All TCP Inbound 2379-2380 etcd server client API kube-apiserver, etcd TCP Inbound 10250 Kubelet API Self, Control plane TCP Inbound 10251 kube-scheduler Self TCP Inbound 10252 kube-controller-manager Self Worker 节点 # 规则 方向 端口范围 作用 使用者 TCP Inbound 10250 Kubelet API Self, Control plane TCP Inbound 30000-32767 NodePort Services** All ** NodePort 服务 的默认端口范围。</description></item></channel></rss>