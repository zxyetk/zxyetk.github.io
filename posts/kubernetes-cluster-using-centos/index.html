<!doctype html><html lang=en><head><meta name=generator content="Hugo 0.80.0"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="准备工作 #   一台或多台运行着下列系统的机器:  CentOS 7 RHEL 7   每台机器 2 GB 或更多的 RAM (如果少于这个数字将会影响您应用的运行内存) 2 CPU 核心或更多 集群中的所有机器的网络彼此均能相互连接(公网和内网都可以) 节点之中不可以有重复的主机名，MAC 地址，product_uuid。更多详细信息请参见这里 。 开启主机上的一些特定端口. 更多详细信息请参见这里。 禁用 Swap 交换分区。为了保证 kubelet 正确运行，您 必须 禁用交换分区。  确保每个节点上 MAC 地址和 product_uuid 的唯一性。 #   您可以使用下列命令获取网络接口的 MAC 地址：ip link 或是 ifconfig -a 下列命令可以用来获取 product_uuid sudo cat /sys/class/dmi/id/product_uuid  一般来讲，硬件设备会拥有独一无二的地址，但是有些虚拟机可能会雷同。Kubernetes 使用这些值来唯一确定集群中的节点。如果这些值在集群中不唯一，可能会导致安装失败。
检查网络适配器 #  如果您有一个以上的网络适配器，同时您的 Kubernetes 组件通过默认路由不可达，我们建议您预先添加 IP 路由规则，这样 Kubernetes 集群就可以通过对应的适配器完成连接。
检查所需端口 #  Master 节点 #     规则 方向 端口范围 作用 使用者     TCP Inbound 6443* Kubernetes API server All   TCP Inbound 2379-2380 etcd server client API kube-apiserver, etcd   TCP Inbound 10250 Kubelet API Self, Control plane   TCP Inbound 10251 kube-scheduler Self   TCP Inbound 10252 kube-controller-manager Self    Worker 节点 #     规则 方向 端口范围 作用 使用者     TCP Inbound 10250 Kubelet API Self, Control plane   TCP Inbound 30000-32767 NodePort Services** All    ** NodePort 服务 的默认端口范围。"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="CentOS 安装 Kubernetes 集群"><meta property="og:description" content="准备工作 #   一台或多台运行着下列系统的机器:  CentOS 7 RHEL 7   每台机器 2 GB 或更多的 RAM (如果少于这个数字将会影响您应用的运行内存) 2 CPU 核心或更多 集群中的所有机器的网络彼此均能相互连接(公网和内网都可以) 节点之中不可以有重复的主机名，MAC 地址，product_uuid。更多详细信息请参见这里 。 开启主机上的一些特定端口. 更多详细信息请参见这里。 禁用 Swap 交换分区。为了保证 kubelet 正确运行，您 必须 禁用交换分区。  确保每个节点上 MAC 地址和 product_uuid 的唯一性。 #   您可以使用下列命令获取网络接口的 MAC 地址：ip link 或是 ifconfig -a 下列命令可以用来获取 product_uuid sudo cat /sys/class/dmi/id/product_uuid  一般来讲，硬件设备会拥有独一无二的地址，但是有些虚拟机可能会雷同。Kubernetes 使用这些值来唯一确定集群中的节点。如果这些值在集群中不唯一，可能会导致安装失败。
检查网络适配器 #  如果您有一个以上的网络适配器，同时您的 Kubernetes 组件通过默认路由不可达，我们建议您预先添加 IP 路由规则，这样 Kubernetes 集群就可以通过对应的适配器完成连接。
检查所需端口 #  Master 节点 #     规则 方向 端口范围 作用 使用者     TCP Inbound 6443* Kubernetes API server All   TCP Inbound 2379-2380 etcd server client API kube-apiserver, etcd   TCP Inbound 10250 Kubelet API Self, Control plane   TCP Inbound 10251 kube-scheduler Self   TCP Inbound 10252 kube-controller-manager Self    Worker 节点 #     规则 方向 端口范围 作用 使用者     TCP Inbound 10250 Kubelet API Self, Control plane   TCP Inbound 30000-32767 NodePort Services** All    ** NodePort 服务 的默认端口范围。"><meta property="og:type" content="article"><meta property="og:url" content="https://zxye.tk/posts/kubernetes-cluster-using-centos/"><meta property="article:published_time" content="2019-08-02T20:33:54+00:00"><meta property="article:modified_time" content="2019-08-02T20:33:54+00:00"><title>CentOS 安装 Kubernetes 集群 | 仲夏叶 | 科技</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.134b70e5316650a530cb42e4e8630b2a01d532bebfc0337028211175336e4806.css integrity="sha256-E0tw5TFmUKUwy0Lk6GMLKgHVMr6/wDNwKCERdTNuSAY="><script defer src=/en.search.min.3fad425eb896bf605587c421cf613958456e6b1975e759c6731356bfe51de792.js integrity="sha256-P61CXriWv2BVh8Qhz2E5WEVuaxl151nGcxNWv+Ud55I="></script></head><body><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><nav><h2 class=book-brand><a href=/><span>仲夏叶 | 科技</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>CentOS 安装 Kubernetes 集群</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#准备工作>准备工作</a><ul><li><a href=#确保每个节点上-mac-地址和-product_uuid-的唯一性>确保每个节点上 MAC 地址和 product_uuid 的唯一性。</a></li><li><a href=#检查网络适配器>检查网络适配器</a></li><li><a href=#检查所需端口>检查所需端口</a></li><li><a href=#安装-kubeadm-kubelet-和-kubectl>安装 kubeadm, kubelet 和 kubectl</a></li><li><a href=#在-master-节点上配置-kubelet-所需的-cgroup-驱动>在 Master 节点上配置 kubelet 所需的 cgroup 驱动</a></li></ul></li></ul><ul><li><ul><li><a href=#heading></a></li></ul></li></ul></nav></aside></header><article class=markdown><h1><a href=/posts/kubernetes-cluster-using-centos/>CentOS 安装 Kubernetes 集群</a></h1><h5>August 2, 2019</h5><div><a href=/tags/kubernetes/>kubernetes</a>,
<a href=/tags/centos/>centos</a>,
<a href=/tags/k8s/>k8s</a></div><p><h2 id=准备工作>准备工作
<a class=anchor href=#%e5%87%86%e5%a4%87%e5%b7%a5%e4%bd%9c>#</a></h2><ul><li>一台或多台运行着下列系统的机器:<ul><li>CentOS 7</li><li>RHEL 7</li></ul></li><li>每台机器 2 GB 或更多的 RAM (如果少于这个数字将会影响您应用的运行内存)</li><li>2 CPU 核心或更多</li><li>集群中的所有机器的网络彼此均能相互连接(公网和内网都可以)</li><li>节点之中不可以有重复的主机名，MAC 地址，product_uuid。更多详细信息请参见<a href=https://kubernetes.io/zh/docs/setup/independent/install-kubeadm/#verify-the-mac-address-and-product-uuid-are-unique-for-every-node>这里</a> 。</li><li>开启主机上的一些特定端口. 更多详细信息请参见<a href=https://kubernetes.io/zh/docs/setup/independent/install-kubeadm/#check-required-ports>这里</a>。</li><li>禁用 Swap 交换分区。为了保证 kubelet 正确运行，您 <strong>必须</strong> 禁用交换分区。</li></ul><h3 id=确保每个节点上-mac-地址和-product_uuid-的唯一性>确保每个节点上 MAC 地址和 product_uuid 的唯一性。
<a class=anchor href=#%e7%a1%ae%e4%bf%9d%e6%af%8f%e4%b8%aa%e8%8a%82%e7%82%b9%e4%b8%8a-mac-%e5%9c%b0%e5%9d%80%e5%92%8c-product_uuid-%e7%9a%84%e5%94%af%e4%b8%80%e6%80%a7>#</a></h3><ul><li>您可以使用下列命令获取网络接口的 MAC 地址：<code>ip link</code> 或是 <code>ifconfig -a</code></li><li>下列命令可以用来获取 product_uuid <code>sudo cat /sys/class/dmi/id/product_uuid</code></li></ul><p>一般来讲，硬件设备会拥有独一无二的地址，但是有些虚拟机可能会雷同。Kubernetes 使用这些值来唯一确定集群中的节点。如果这些值在集群中不唯一，可能会导致安装<a href=https://github.com/kubernetes/kubeadm/issues/31>失败</a>。</p><h3 id=检查网络适配器>检查网络适配器
<a class=anchor href=#%e6%a3%80%e6%9f%a5%e7%bd%91%e7%bb%9c%e9%80%82%e9%85%8d%e5%99%a8>#</a></h3><p>如果您有一个以上的网络适配器，同时您的 Kubernetes 组件通过默认路由不可达，我们建议您预先添加 IP 路由规则，这样 Kubernetes 集群就可以通过对应的适配器完成连接。</p><h3 id=检查所需端口>检查所需端口
<a class=anchor href=#%e6%a3%80%e6%9f%a5%e6%89%80%e9%9c%80%e7%ab%af%e5%8f%a3>#</a></h3><h4 id=master-节点>Master 节点
<a class=anchor href=#master-%e8%8a%82%e7%82%b9>#</a></h4><table><thead><tr><th style=text-align:left>规则</th><th style=text-align:left>方向</th><th style=text-align:left>端口范围</th><th style=text-align:left>作用</th><th style=text-align:left>使用者</th></tr></thead><tbody><tr><td style=text-align:left>TCP</td><td style=text-align:left>Inbound</td><td style=text-align:left>6443*</td><td style=text-align:left>Kubernetes API server</td><td style=text-align:left>All</td></tr><tr><td style=text-align:left>TCP</td><td style=text-align:left>Inbound</td><td style=text-align:left>2379-2380</td><td style=text-align:left>etcd server client API</td><td style=text-align:left>kube-apiserver, etcd</td></tr><tr><td style=text-align:left>TCP</td><td style=text-align:left>Inbound</td><td style=text-align:left>10250</td><td style=text-align:left>Kubelet API</td><td style=text-align:left>Self, Control plane</td></tr><tr><td style=text-align:left>TCP</td><td style=text-align:left>Inbound</td><td style=text-align:left>10251</td><td style=text-align:left>kube-scheduler</td><td style=text-align:left>Self</td></tr><tr><td style=text-align:left>TCP</td><td style=text-align:left>Inbound</td><td style=text-align:left>10252</td><td style=text-align:left>kube-controller-manager</td><td style=text-align:left>Self</td></tr></tbody></table><h4 id=worker-节点>Worker 节点
<a class=anchor href=#worker-%e8%8a%82%e7%82%b9>#</a></h4><table><thead><tr><th style=text-align:left>规则</th><th style=text-align:left>方向</th><th style=text-align:left>端口范围</th><th style=text-align:left>作用</th><th style=text-align:left>使用者</th></tr></thead><tbody><tr><td style=text-align:left>TCP</td><td style=text-align:left>Inbound</td><td style=text-align:left>10250</td><td style=text-align:left>Kubelet API</td><td style=text-align:left>Self, Control plane</td></tr><tr><td style=text-align:left>TCP</td><td style=text-align:left>Inbound</td><td style=text-align:left>30000-32767</td><td style=text-align:left>NodePort Services**</td><td style=text-align:left>All</td></tr></tbody></table><p><code>**</code> <a href=https://kubernetes.io/docs/concepts/services-networking/service/>NodePort 服务</a> 的默认端口范围。</p><p>任何使用 <code>*</code> 标记的端口号都有可能被覆盖，所以您需要保证您的自定义端口的状态是开放的。</p><p>虽然主节点已经包含了 etcd 的端口，您也可以使用自定义的外部 etcd 集群，或是指定自定义端口。 您使用的 pod 网络插件 (见下) 也可能需要某些特定端口开启。由于各个 pod 网络插件都有所不同，请参阅他们各自文档中对端口的要求。</p><h3 id=安装-kubeadm-kubelet-和-kubectl>安装 kubeadm, kubelet 和 kubectl
<a class=anchor href=#%e5%ae%89%e8%a3%85-kubeadm-kubelet-%e5%92%8c-kubectl>#</a></h3><p>您需要在每台机器上都安装以下的软件包：</p><ul><li><code>kubeadm</code>: 用来初始化集群的指令。</li><li><code>kubelet</code>: 在集群中的每个节点上用来启动 pod 和 container 等。</li><li><code>kubectl</code>: 用来与集群通信的命令行工具。</li></ul><p>kubeadm <strong>不能</strong> 帮您安装或管理 <code>kubelet</code> 或 <code>kubectl</code> ，所以您得保证他们满足通过 kubeadm 安装的 Kubernetes 控制层对版本的要求。如果版本没有满足要求，就有可能导致一些难以想到的错误或问题。然而控制层与 kubelet 间的 <em>小版本号</em> 不一致无伤大雅，不过请记住 kubelet 的版本不可以超过 API server 的版本。例如 1.8.0 的 API server 可以适配 1.7.0 的 kubelet，反之就不行了。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#e6db74>&lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
</span><span style=color:#e6db74>[kubernetes]
</span><span style=color:#e6db74>name=Kubernetes
</span><span style=color:#e6db74>baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64
</span><span style=color:#e6db74>enabled=1
</span><span style=color:#e6db74>gpgcheck=1
</span><span style=color:#e6db74>repo_gpgcheck=1
</span><span style=color:#e6db74>gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg
</span><span style=color:#e6db74>exclude=kube*
</span><span style=color:#e6db74>EOF</span>

<span style=color:#75715e># 将 SELinux 设置为 permissive 模式(将其禁用)</span>
setenforce <span style=color:#ae81ff>0</span>
sed -i <span style=color:#e6db74>&#39;s/^SELINUX=enforcing$/SELINUX=permissive/&#39;</span> /etc/selinux/config

yum install -y kubelet kubeadm kubectl --disableexcludes<span style=color:#f92672>=</span>kubernetes

systemctl enable kubelet <span style=color:#f92672>&amp;&amp;</span> systemctl start kubelet
</code></pre></div><p><strong>请注意：</strong></p><p>- 通过命令 <code>setenforce 0</code> 和 <code>sed ...</code> 可以将 SELinux 设置为 permissive 模式(将其禁用)。 只有执行这一操作之后，容器才能访问宿主的文件系统，进而能够正常使用 Pod 网络。您必须这么做，直到 kubelet 做出升级支持 SELinux 为止。 - 一些 RHEL/CentOS 7 的用户曾经遇到过：由于 iptables 被绕过导致网络请求被错误的路由。您得保证 在您的 <code>sysctl</code> 配置中 <code>net.bridge.bridge-nf-call-iptables</code> 被设为1。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>cat <span style=color:#e6db74>&lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf
</span><span style=color:#e6db74>net.bridge.bridge-nf-call-ip6tables = 1
</span><span style=color:#e6db74>net.bridge.bridge-nf-call-iptables = 1
</span><span style=color:#e6db74>EOF</span>
sysctl --system
</code></pre></div><p>kubelet 现在每隔几秒就会重启，因为它陷入了一个等待 kubeadm 指令的死循环。</p><h3 id=在-master-节点上配置-kubelet-所需的-cgroup-驱动>在 Master 节点上配置 kubelet 所需的 cgroup 驱动
<a class=anchor href=#%e5%9c%a8-master-%e8%8a%82%e7%82%b9%e4%b8%8a%e9%85%8d%e7%bd%ae-kubelet-%e6%89%80%e9%9c%80%e7%9a%84-cgroup-%e9%a9%b1%e5%8a%a8>#</a></h3><p>使用 Docker 时，kubeadm 会自动为其检测 cgroup 驱动在运行时对 <code>/var/lib/kubelet/kubeadm-flags.env</code> 文件进行配置。 如果您使用了不同的 CRI， 您得把 <code>/etc/default/kubelet</code> 文件中的 <code>cgroup-driver</code> 位置改为对应的值，像这样：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>KUBELET_EXTRA_ARGS<span style=color:#f92672>=</span>--cgroup-driver<span style=color:#f92672>=</span>&lt;value&gt;
</code></pre></div><p>这个文件将会被 <code>kubeadm init</code> 和 <code>kubeadm join</code> 用于为 kubelet 获取 额外的用户参数。</p><p>请注意，您<strong>只</strong>需要在您的 cgroup driver 不是 <code>cgroupfs</code> 时这么做，因为 <code>cgroupfs</code> 已经是 kubelet 的默认值了。</p><p>需要重启 kubelet：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>systemctl daemon-reload
systemctl restart kubelet
</code></pre></div><h1 id=使用-kubeadm-创建一个单主集群>使用 kubeadm 创建一个单主集群
<a class=anchor href=#%e4%bd%bf%e7%94%a8-kubeadm-%e5%88%9b%e5%bb%ba%e4%b8%80%e4%b8%aa%e5%8d%95%e4%b8%bb%e9%9b%86%e7%be%a4>#</a></h1><h3 id=heading><a class=anchor href=#heading>#</a></h3></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><nav id=TableOfContents><ul><li><a href=#准备工作>准备工作</a><ul><li><a href=#确保每个节点上-mac-地址和-product_uuid-的唯一性>确保每个节点上 MAC 地址和 product_uuid 的唯一性。</a></li><li><a href=#检查网络适配器>检查网络适配器</a></li><li><a href=#检查所需端口>检查所需端口</a></li><li><a href=#安装-kubeadm-kubelet-和-kubectl>安装 kubeadm, kubelet 和 kubectl</a></li><li><a href=#在-master-节点上配置-kubelet-所需的-cgroup-驱动>在 Master 节点上配置 kubelet 所需的 cgroup 驱动</a></li></ul></li></ul><ul><li><ul><li><a href=#heading></a></li></ul></li></ul></nav></aside></main></body></html>