[{"content":"什么是测试陷阱 测试陷阱是指不必要的并且可能意外导致测试不那么有效，高效或者更令人沮丧的表现的决策、思维、行为或不作为。基本上，测试陷阱是一个经常发生的搞砸测试的方式，当测试人员、管理人员、需求工程师和其他测试利益相关者犯了测试相关的错误，并由此产生意想不到的负面后果时，项目就陷入了测试陷阱。\n从某种意义上说，测试陷阱的描述构成了测试反模式。然而，术语“陷阱”是专门选择，为那些粗心大意或外行的人唤起隐蔽或不易识别的陷阱的形象。与任何陷阱一样，最好是避免测试陷阱，而不是陷入陷阱后将自己和项目挖出来。\n陷阱分类 许多测试陷阱发生在软件依赖系统和软件应用的开发或维护期间。虽然可能没有项目是如此糟糕地管理和执行，从而体验这些缺陷中的大多数，但大多数项目将遭受其中几个。同样，虽然这些测试陷阱并不保证失败，但它们必然带来需要管理的严重风险。\n在测试过程中经常观察到的92种陷阱。这些缺陷分类如下：\n 一般测试陷阱  测试计划和进度陷阱 利益相关者的参与和承诺陷阱 管理相关测试陷阱 人员配备陷阱 测试过程陷阱 测试工具和环境陷阱 测试沟通陷阱 需求相关测试陷阱   测试类型相关陷阱  单元测试陷阱 集成测试陷阱 专业工程测试陷阱 系统测试陷阱 系统的系统测试陷阱 回归测试陷阱    共同的负面后果 虽然不同的测试陷阱有不同的负面后果，它们都趋向于促进以下总体最终问题：\n 测试有效性较低。  更多遗留缺陷躲过测试进入交付系统。 尽管付出额外的成本和时间，软件依赖系统仍然带有比预期的或者必要的更多的遗留缺陷交付并投入运行。   测试效率较低。  要达到没有陷阱能达到的相同质量，需要更多的时间和精力。 因为在开发后期花费额外的、计划外的时间和精力去发现并修复缺陷，系统交付延迟并且超出预算。 测试人员必须不可持续地长时间工作，这使他们变得筋疲力尽，因此，会犯过多的错误。 一些缺陷发现的时间比应该发现时间晚，使得缺陷更难定位和修复。   测试人员的士气受到影响。  糟糕的测试效率和有效性，使得测试人员的工作比需要的更长、更困难。 糟糕的测试有效性和由此带来的遗留缺陷的增加削弱了测试人员对工作的自豪感。    一般建议 除了在下文缺陷描述中提供的单个缺陷相关的建议之外，以下建议普遍适用于大多数常见的测试陷阱。\n 预防建议。这些一般建议可以在最初防止落入陷阱。  更新测试过程。测试人员、首席工程师和过程工程师更新测试过程以帮助项目避免落入测试陷阱，若做不到这一点，那么在已经落入陷阱时能够及时发现。 将陷阱当做风险。当相关时，陷阱应该正式在项目的风险库中识别为风险，并做相应管理。 正式要求解决方案。客户代表在适当的文档中正式要求测试陷阱的解决方案，如需求建议书、合同和工作说明书。 内部强制要求解决方案。管理人员、首席工程师（开发团队领导）或者首席测试人员（测试团队领导）在相应的文档中明确强制要求测试陷阱的解决方案，如系统工程管理计划、系统开发计划、测试计划文档或测试策略。 提供培训。首席测试人员或培训人员给相关人员（如采购人员、管理层、测试人员和质量保证人员）提供适当数量和水平的测试培训，涵盖潜在的测试陷阱和如何预防、检测及应对。 确保管理层的支持。管理人员明确说明（并提供）对测试的支持，以及避免经常发生的测试陷阱的必要性。   检测建议。以下一般建议使得识别和诊断现有的陷阱成为可能。  评估文档。评审、审查或走查测试相关的文档（例如，测试计划和开发计划的测试部分）。 确保监督。测试过程执行时提供采购方、管理层、质量保证和同行的监督。 考虑度量指标。收集、分析并向利益相关者（例如，采购方、管理人员、技术领导或首席工程师和首席测试人员）报告相关的测试指标。   应对建议。一旦检测到陷阱，以下一般建议有助于缓解。  拒绝不充分的测试文档。客户代表、管理人员和首席工程师拒绝接受测试相关的文档，指导已识别的陷阱得到解决。 拒绝交付。客户代表、管理人员和首席工程师拒绝接受被测系统或软件，直到已识别的陷阱（例如，测试环境、测试过程或测试用例）得到解决。然后对相关缺陷进行优先级排序和修复后重新运行测试。 提供培训。首席测试人员或培训人员给相关人员（如采购人员、管理人员、测试人员和质量保证人员）提供适当数量和水平的补救测试培训，涵盖以观察到的测试陷阱和如何预防、检测及应对测试陷阱。 更新过程。首席工程师、首席测试人员或过程工程师更新测试过程文档（例如，流程、指南、模板、工具手册），以最大限度地减少观察到的测试陷阱再次出现的可能性。 报告陷阱的发生。测试人员应向项目管理团队报告陷阱的发生，包括测试经理、项目经理和技术负责人。 将陷阱当做风险。如果相关时，陷阱应该正式在项目的风险库中识别为风险，并做相应管理。     摘抄自《测试反模式——有效规避常见的92种测试陷阱》（美）Donald G. Firesmish\n","date":"2020-12-21","permalink":"https://www.zxye.tk/posts/common-system-and-software-testing-pitfalls/","tags":["book","testing"],"title":"测试陷阱分类"},{"content":"测试员有很多不同的背景，测试团队是多元化的集体，但是大多数人都同意：测试员的思考方式是不同的。怎么不同？有人说测试员是“消极”思维者。测试员会抱怨这种说法，认为自己喜欢征服，他们在报告坏消息时有一种特别的兴奋感。这是一种普遍观点。我们提出另一种观点。测试员并不抱怨，他们提供的是证据。测试员并不喜欢征服，他们喜欢打破产品没有问题的幻觉。测试员并不喜欢发布坏消息，他们喜欢把客户从虚假信念中解放出来。我们的观点是，按测试员的方式思考意味着实践认识论。测试运用的是认识论，不是靠傲慢或谦卑。\n测试运用的是认识论 认识论研究如何认识所了解的东西：研究证据和推理。这是科学实践的基础。研究认识论的人有科学家、教育家和哲学家，当然还有精英级的软件测试员。学习认识论的学生研究科学、哲学和心理学，目标是了解怎样才能改进我们的思维。我们使用的术语比经典定义要宽，以便能够更多地利用批判性思维的最新成果。将认识论运用于软件测试，要问与以下类似的问题：\n 怎么知道软件足够好？ 如果软件并不是足够好，怎样才能知道？ 怎么知道已经完成了足够的测试？  研究认识论有助于更好测试 直接与软件测试有关的认识论问题包括：\n 如何收集和评估证据。 如何进行有效的推论。 如何使用不同逻辑形式。 拥有合理的信念意味着什么。 形式和非形式推理之间的差别。 非形式推理的常见谬误。 自然语言的含义与模糊性。 如何做出好的决策。  研究认识论可帮助测试员设计有效的测试策略，更好地意识到自己工作中的错误，理解自己的测试能够证明什么、不能证明什么，并编写出无懈可击的测试报告。\n 认知心理学是测试的基础 如果说认识论告诉我们的是应该怎样思考，那么认知心理学告诉我们的是我们是怎样思考的。与测试有关的一些问题包括：\n 人的感觉和记忆可靠性。 信念从哪里来。 信念如何影响人的行为。 做出决策所使用的偏见和捷径。 如何了解并分享所知道的信息。 如何考虑复杂事情。 如何识别模式。 如何把想法和实物分类。 如何注意事物之间的差别。 记忆事件中的失真。 如何重新构建部分记忆的事件（例如不可再现的程序错误）。  研究认知心理学有助于理解影响测试员工作成绩的因素，以及影响人们解释自己工作方式的因素。测试应该使用因果关系理论进行系统推理，而不只是查看外部行为，并对照简单的预期描述进行检查。\n测试需要推断，并不只是做输出与预期结果的比较 流行的观点认为，测试员只是执行测试用例，并对照预期结果比较执行结果。这种观点把测试看做是简单的比较活动，没有看到一些聪明人必须设计测试，并确定预期输出。想想看，测试设计人员几乎从来没有得到过应该测试什么的权威指导，更不要说应该期望什么了。可以得到的指导是要解释的主体。在现实生活中，大多数测试设计都是基于推断，或基于与测试员的推断有关的经验。不仅如此，这些推断还要随时间发生变化。像测试员那样思考，就是要掌握探索式推断的艺术。\n探索式推断听起来可能像是奇怪的想法，这意味着要以一种不能事先预测的方式，通过一种思想引出另一种思想，然后再引出下一种思想。\n优秀测试员会进行技术性、创造性、批判性和实用性地思考 各种类型的思考都要考虑测试的实施。但是我们认为需要提出四种主要思考：\n 技术性思考。对技术建模并理解因果关系的能力。这包括诸如相关技术事实的知识和使用工具并预测系统行为的能力。 创造性思考。产生思想并看到可能性的能力。测试员只能以能够想象得到的方式进行测试，只能寻找猜想会存在的问题。 批判性思考。评估思想并进行推断的能力。这包括在自己的思考中发现并消除错误的能力，将产品观察与质量准则关联起来的能力，以及针对特定信念或所建议的行动过程构建有说服力的测试用例的能力。 实用性思考。把想法付诸实践的能力。这种能力包括诸如运用测试工具，并使测试手段和力量与项目范围适应的技能。  总之，像测试员那样思考，会最终导致相信事物可能不像外表看起来那样。不管事物是怎样的，都可能有差别。我们发现，当测试过程以最具破坏性的方式失败时，根本原因最有可能是视野狭窄。换句话说，这不是运行了一万个测试，而本来应该运行一万零一个的问题；问题是没有想象出测试的总体大纲，没有做就算有两倍时间和资源也不会做的测试。\n黑盒测试并不是基于无知的测试 黑盒测试意味着产品内部知识在测试中不起重要作用。大多数测试员都是黑盒测试员。为了做好黑盒测试就要了解用户，了解他们的期望和需要，了解技术，了解软件运行环境的配置，了解这个软件要与之交互的其他软件，了解软件必须管理的数据，了解开发过程，等等。黑盒测试的优势在于测试员可能与程序员的思考不同，因此有可能预测出程序员所遗漏的风险。\n黑盒测试强调有关软件的用户和环境知识，这一点并不是所有人都喜欢的。我们甚至把黑盒测试描述为基于无知的测试，因为测试员自始至终都不了解软件内部代码。我们认为这反映出对测试团队角色的根本误解。我们不反对测试员了解产品的工作原理。测试员对产品的了解得越多，了解产品的方式越多，越能够更好地测试它。但是，如果测试员主要关注的是源代码，以及能够从源代码导出的测试，则测试员所做的工作也许就是程序员已经做过的，并且测试员关于这些代码的知识要少于程序员。制造问题的思路，无法解决问题。\n测试员不只是游客 测试员对产品做的大量不是测试的事，有助于测试员对产品的了解。测试员可以浏览产品，看看产品由什么组成，怎么工作。这样做有很高的价值，但这不能算是测试。测试员和游客之间的差别在于，测试员把精力放在评估产品上，而不只是见证产品。虽然不必事先预测产品应该表现出的行为，但是试验产品能力的活动还没有成为测试，除非而且直到测试员运用某种如果问题存在就能标识的原理或过程时，这种活动才能成为测试。\n探索要求大量思索 探索就是侦查，是没有边界的搜索。可把探索看作是在太空中遨游，需要前向、后向和侧向思索。\n 前向思索。根据已知探索未知，从看到的探索还没有看到的，注意支流和副作用。例如，看到一个打印菜单项，点击看看会发生什么。 后向思索。从怀疑或想象的东西返回到已知，尝试证实或否定自己的推测。例如：怀疑是否有打印这个文档的方法，于是打开菜单并检查是否有打印菜单项。 侧向思索。让自己的工作由于新冒出的想法而转移，然后再将探索主题返回到主线索上。例如：这个图很有意思。嘿！我想该打印一些更复杂的图，看看会怎么样。  即使没有要测试的产品，也可以探索。可以使用同样的思索过程探索一组文档，或与程序员面谈。通过构建更丰富、更具想象力的产品模型，探索也会不断取得进展。这些模型以后会使测试员设计出有效的测试。\n运用试探法快速产生测试思路 试探法是一种经验规则，是一种基于经验做出猜测的方法。由于可能的测试用例数量是无限的，因此肯定要选出在所面临的时间和预算约束条件下有效的少量测试用例。有经验的测试员会收集并共享能够改进其猜测质量的测试试探方法。一组好的试探方法有助于很快地生成测试。以下是采用试探测试的一些例子：\n 测试边界。边界更有可能暴露规格说明的模糊问题。 测试所有错误信息。错误处理代码与主流功能代码相比，一般比较弱。 测试与程序员的配置不同的配置。程序员已经偏信自己的配置没有问题。 运行比较难设置的测试。在其他条件相同的情况下，易于设置的测试更有可能已经被执行过。 避免冗余测试。如果某个测试实际上是重复其他测试，就不会产生新价值。  为了明智地运用试验法，请注意：试探法中并没有智慧，智慧来自测试员。试探法所能够做的，只不过就是为测试员的思考提出建议。盲目使用自己并不了解的试探法并不是好的测试实践。在收集测试方法时，要了解每个方法背后的原理，以及更适用和不太适用的条件。\n测试员不能避免偏向，但是可以管理偏向 测试员是有偏向的，这使得测试员选择一部分测试的可能性要比其他测试大。如果有一个很长的编辑字段，测试员也许更可能输入诸如111111111111，而不是32432874238，因为输入字符重复的字符串，要比从0到9随机选择数字更容易。也许这是一种很小的偏向，但仍是一种偏向。更糟的偏向是，大多数测试员倾向于测试最可视的功能，不管是不是最重要的功能。此外，大多数测试员还倾向于考虑认为与自己类似的用户，倾向于使用非常简单、非常荒谬的输入，而不是具有中等复杂度的现实输入。\n以下是一些常见偏向：\n 同化偏向。更有可能把未来的测试结果解释为总体上证实自己对产品的看法。 证实偏向。更有可能关注确实会证实自己对产品看法的测试结果。 可用性偏向。如果头脑中已经想到一种用户以某种方式操作的场景，则更有可能认为这种操作更常出现。 最初印象偏见。更信任所做的第一次观察。 最新印象偏见。更信任所做的最近一次观察。 框架效应。对错误报告的反应与措辞有很大关系，不管其真正含义如何。 知名偏向。把碰巧认识的用户意见放在更重要的地位。 表达偏向。期望较小的问题也许有较小的原因，而严重问题会有大原因。  测试员不能避免这些偏向，因为这些偏向在很大程度上已经固化在头脑中。测试员能够做的是管理偏向。例如，只需通过研究偏向并在实践中注意，这样在思考时就可以更好地进行补偿。多样化也可以抵御过强偏向。如果测试员集体谈论测试问题，可以将一个测试员的偏向降低到最低限度。\n如果遗漏一个问题，检查这种遗漏是意外还是策略的必然结果 如果猜硬币，猜的是正面，出现的却是反面，这是否意味着做出了差的决策？以任何理性的观点看都不是这样。除非在硬币上做了手脚，否则出现任何一面的机会都是50%。出现反面没有什么可奇怪的，只是不够幸运罢了。决策策略没有问题。\n在测试过程中没有发现程序错误时也存在同样问题，同样也会困扰客户。在研究测试策略出现了什么问题之前，先不要自责。出现遗漏，是否因为忠实地执行了好的测试策略，并只是碰巧没有发现那个特定的问题？如果是这样，可保持原有方针不变。确实有这种情况。但是，如果遗漏程序错误是因为测试策略关注了错的问题类型，可利用这个机会改进测试策略。\n所有测试都视图回答某些问题 所执行的所有测试，都是要回答有关现实的产品和应该得到的产品之间关系的某个问题。有时测试员完全没有意识到自己在回答问题。如果测试员只是在寻找明显的问题可能还好，但是在很多情况下，问题并不会闪烁着“请报告我”的提示自己跳出来。产品的有些错误行为用户可能一眼就会看出，尽管测试员可能没有注意到。在任何测试活动中，都要问自己什么样的问题应该推动自己评估测试策略，否则就会更像是游客，而不是测试员。\n困惑是一种测试工具 当测试员感到困惑时，这可能是某种重要的预示。\n 规格说明不清楚吗？规格说明中的模糊点，常常是为了掩盖有影响力的项目相关人员之间的重要分歧。 产品不清楚吗？产品可能有严重问题。 用户文档不清楚吗？产品的这个部分可能太复杂，有太多的特例和不一致性要描述。 内部问题只是难以理解吗？我们试图自动化的有些系统具有内在的复杂性，或包含复杂的技术问题。程序员也认为它们复杂、困难，并导致自己犯遗漏、误解和过于简化的错误。  测试员对产品、技术和一般测试问题了解得越多，自己的困惑就会成为更有力的指南针，指出重要问题所在。\n在测试过程中，如果对产品一无所知，那么至少知道自己在困惑。在这种情况下，困惑可以成为最佳交付内容，即提出也许其他人没有勇气提出的问题。\n清新的眼光会发现失效 理解事物，是把新信息吸收到已知信息中，同时修改已知的信息以适应新信息的高智力过程。测试员在理解了产品或功能部件之后，会在头脑中形成映射，并且头脑不再那么努力工作。对于测试员来说这可能是个问题。当非常了解产品后，会对产品做出更多的假设，并更少检查这些假设。\n这种情况对于测试至少有三点提示：\n 第一次接触产品或功能时，要特别注意使自己困惑和烦恼的地方。这可能说明用户也会有类似反应。 当与团队的新成员一起工作时，与他们一起测试。观察他们在了解产品时的反应。 警惕陷入测试惯例。即使没有遵循严格的测试脚本，也可能对特定功能太熟悉，以至于以越来越窄的方式进行测试。在任何可能的地方引入多样性，或改由其他测试员负责。  测试过程的一个重要成果，是更好、更聪明的测试员 我们经常听到反对产生很少或不产生文档的测试的理由，好像测试的唯一价值就是通过测试产生的文档。这种观点忽略了测试的一种意义深远的重要产品：测试员本身。\n好的测试员永远都在学习，随着项目的进展，他们不断加深对产品的了解，逐渐从各个方面提高对产品的反应能力和敏感性。了解产品并已经经历过一两次产品发布的有经验的测试员，即使没有任何指示，但与有一套如何测试产品的书面指示的没有经验的测试员相比，他们测试的有效性也要高得多。\n软件测试领域内的一些顾问和论文作者看起来相信，只要提供测试过程，测试效果差的测试员就可以变成测试效果好的测试员。在我们看来，这是一种差的实践，这反映出他们对测试和进行有效测试的人的根本误解。\n在评估测试过程时，首先要看项目测试员的素质，要看他们怎么思考，以及这种思考怎样对其行为产生影响。只有掌握了这些信息才能评估他们的工作产品。\n除非重新发明测试，否则不能精通测试 不要彻底改造轮子。请稍等一下，难道轮子不是历史上被重新发明次数最多的吗？这不是好事情吗？毕竟我们的汽车是装在充气轮胎上，而不是花岗岩圆盘上。轮子如果说不是数以百万计的话，也有数以千计的变种。也许我们可以从中得到启发。在我们看来，重新发明东西至少有两个原因：通过改造使其适应新条件，了解其工作原理。而要掌握它，这两个方面都需要。\n我们有的同事忠告测试专业的学生不要重新发明测试，也不要重新发明测试思想。我们不同意这种观点。这就像是学习科学又不想做实验一样。通过其他思想家进行学习是没有错的，我们认为这样学习是很重要的。但是如果这是学习的唯一方式，那永远也不会成为测试技艺的行家。这样的人将是技术员，但不会再进一步了。按照指示做不会掌握任何东西，就像要沿高速路上火星一样。我们提倡要伟大的机械师和伟大的程序员那样地学习测试：把东西分解，琢磨其工作原理，再以新的方式组装到一起。不要把自己限制为只是接受智慧的服务者，而应该使自己成为智慧的创造者。\n在学习过程初期，要重新发明不是非常好的测试、想法、手段和文档。这是正常的。要永远使头脑运转，观察其他测试员，研究和不断评估如何筛选自己的思想。如果要善于做到这一点，就必须实践。\n我们这样做已经有很多年了，我们仍然在重新发明，仍然在反思老的想法。我们所尊敬的每个同事都是这样走向精通之路的。\n 摘抄自《软件测试经验与教训》\n","date":"2020-07-01","permalink":"https://www.zxye.tk/posts/think-like-a-tester/","tags":["book","testing"],"title":"按测试员的方式思考"},{"content":"一个角色就是一种关系。这意味着人们不能控制自己的角色，但可以协商。别人期望从测试员那里得到的可能并不合理。当测试员由于低质量的产品受到指责时（这种事时有发生），不管是谁指责，可能都存在分不清角色的问题。也许他们认为测试员的工作，就是在产品交付之前使用“质量魔术棒”敲打产品，他们也许认为测试员敲打得还不够狠。\n当测试员清楚了自己的角色之后，在协商角色内容时，就有了在可能出现的任何情况下确立对自己预期的基础。但是，即使是清晰和恰当的测试角色也是一种苛求。\n测试员的使命决定要做的一切 测试员的使命，可能要取决于自己的行业、公司、项目或团队的个性，测试项目也千差万别。把测试作为一种工艺发展的挑战，一直是建立测试实践对话所面临的困难，这种测试实践要跨越我们之间的文化和技术差异。这些差异中的很多内容，决定了测试团队的不同使命。以下任何要求都可能决定测试员的使命。\n 快速找出重要软件问题。 对产品质量提出总体评估。 确认产品达到某种具体标准。 帮助客户改进产品质量和可测试性。 保证测试过程能够达到可分清责任的标准。 就测试和测试员协作方式培训客户。 采用特定的方法集或遵循特定的规则集。 帮助预测和控制成本。 帮助客户改进其过程。 以最小化成本、时间或尽可能减少副作用的方式，完成自己的工作。 为满足特定客户要求，完成所有必要的工作。  如果测试员将时间和精力都投入到客户并不关心的需求上，就会冒做无关工作或生产率低的风险。测试员要与自己的经理协商使命问题，并明确使命，如果不能就使命达成一致意见，就不会有做任何工作的好基础。\n**如果测试员不知道该做什么怎么办？**一种回答是评审使命。这样做可以找出自己的核心问题。如果测试员明确自己的测试使命，就可以为自己的工作辩护，并明确地确定下一步要做什么。测试员还可以用简单的描述，向其他人解释自己的角色。如果由于某种原因不能完成自己的使命，应该立即把这个问题汇报给管理层。\n**如果测试员确切地知道要做什么该怎么办？**经常重新考虑自己的使命，保证自己的计划不会由于过于偏重测试问题的一个方面，而忽略其他方面。\n 测试员为很多客户服务 测试是一种服务角色，要乐于接受这种角色，因为测试员提供的服务是至关重要的。服务就意味着有客户，即要被服务的人。测试员是否成功，主要是看其是否很好地满足了客户的要求和最佳利益。这不会太难，不过测试会有很多客户，这些客户都有自己的需要，而且他们的各种需要不一定一致。\n 项目经理。项目经理有资格了解测试员的工作进展并施加影响。测试员根据要求向其报告工作状态。指挥项目是项目经理的特权。测试员的责任就是告诉项目经理自己能做什么，不能做什么，有关项目的决策和条件会对测试产生什么影响。 程序员。通过尽可能迅速地提供好的错误报告，使得程序员的工作更容易一些。努力提高自己的技能并了解产品，以免用错误的或用毫无意义的报告浪费程序员的时间。如果测试员可以做到这一点，就可以赢得更多的信任，而这种信任又可以转化为支持和影响。 技术文档编写员。与测试员一样，负责编写文档和在线帮助的技术文档编写员也不能得到产品的完整信息。测试员可以帮助他们理解产品到底怎样发挥效能，并为其指出文档中的错误。技术文档编写员也会帮助测试员。当技术文档编写员研究产品，以及必须阅读文档的用户会怎样使用产品时，会了解到一些测试员不知道的信息。如果测试员与技术文档编写员有很好的关系，编写员就会告诉测试员有关产品的新特性、新用法、测试计划中的漏洞和他们所发现的软件问题。这些问题中的一部分永远也不会被报告，除非某个文档编写员知道哪个测试员关心这些程序问题。 技术支持员。遗留在产品中的任何问题都会为技术支持员带来负担。测试员通过告诉技术支持员可能会给用户带来麻烦的产品问题，向其提供服务。如果测试员在开发期间与技术支持员一起工作，有时技术支持员会帮助测试员找出应该更正的软件问题。测试员也应该通过研究发现的难题，为技术支持员提供帮助。通过这种方式，能够把测试员与技术支持员拉得更近，进而与客户也更近了。 市场开发员。市场开发员需要了解产品中任何与产品应该提供给客户的关键利益不一致的地方。对于程序员来说是很小的程序问题，对于市场开发员来说可能会是至关重要的问题。他们也许能意识到这种程序问题会使客户较难完成某种重要任务。此外，通过评审市场开发计划文档或描述，测试员可以帮助市场开发员对产品能力有更精确的认识。 管理层和项目相关人员。测试员服务于公司业务，这也是为什么测试员必须小心，不要像个质量狂，而不是通情达理的人的原因。特别是到了项目要结束的时候，测试员要以兼顾公司短期和长期利益的方式完成自己的职责。要以明确、简洁的词汇编写测试状态报告，一遍执行经理能够感到有做出决策的依据。 用户。在测试员的心中，要想着将要使用该产品的人。当然，用户的满意是项目的最高利益。但是还要考虑满足主要用户对项目团队的特殊要求。  以上列出的各条没有什么特别顺序，不过在实际项目中可能有一定顺序，因此要认真研究，找出对项目最重要的人，找出要服务的人。这是做好测试工作的第一步。\n当心“完备的”测试 测试员的任务就是找出并报告重要的程序问题，但是不会发现所有的程序问题。为了发现全部程序错误，测试员必须检查所有可能有问题的地方，要在所有可能发生的不同条件下观察这些地方，还需要一种十分可靠的方法，当所有类型的程序错误发生时，都能够识别出来。如果测试员认为自己能够做到这些，那么要么产品非常简单，要么测试员的想象力太差。\n知道并承认自己不能做所有的事之后，测试员必须选择如何使用自己的时间。\n有一些测试员承认自己不知道是否发现了产品中的全部问题，但仍然不准确地讨论结束测试的含义。”对这个产品我需要测试5天“可以解释为，他可以在5天之内对产品进行完备的测试，也可能意味着他会在5天内发现所有问题。完备性常常是隐含地表示出来的，而不是明说出来的。不管是哪种情况，这都是必须小心对待的概念。请考虑完备测试可能的含义：\n 完全发现了产品中的每个问题。 完全检查了产品的每个部分。 完成了自认为是有用和经济的测试。 尽自己所能，完全达到了项目团队制定的目标。 完成了约定的测试。 完成了在一定条件下人所能够测试的所有内容。 完成了自己所承担的测试部分，不考虑其他人的工作。 完成了对产品很广、但是不深的测试。 完成了对产品的一种测试。 用完了分配给测试的时间。  如果测试员小心地澄清自己的意思，不要有“完备”、“完成”、“结束”等含义，则可能会安全，由于有些工作没有做而受到的责备可能更少，在收到责备时可以更好地为自己辩护。请注意，”完备“的定义并不是在项目一开始就能够最终确定的，随着测试项目的进展，随着新测试任务的突然出现，需要重新考虑。\n为了解决在完备性上的普遍沟通问题，可让客户想想了解测试过程。总结自己实施的测试，以及为什么值得实施这些测试，并告诉客户自己没有做的其他值得做的测试，以及为什么没有做这些测试。\n迅速找出重要程序问题 测试员的使命很可能包括找出重要的（与无意义相反）程序问题，而且要迅速找出。如果是这样，那么这对测试员所执行的测试意味着什么呢？\n 首先测试经过变更的部分，然后测试没有变化的部分。修改和更新都意味着新的风险。 首先测试核心功能，然后测试辅助功能，测试产品所完成的关键和常用功能，测试完成产品基本任务的功能。 首先测试能力，然后测试可靠性。先测试每个功能是否完全能用，然后再深入检查任何一个功能在很多不同条件下表现如何。 首先测试常见情况，然后测试少见情况。使用常用的数据和使用场景。 首先测试场景威胁，然后测试罕见威胁。用最有可能出现的压力和错误情况进行测试。 首先测试影响大的问题，然后测试影响小的问题。测试在出现失效的情况下会产生大量破坏的产品部件。 首先测试最需要的部分，然后测试没有要求的部分。测试对团队其他人有重要意义的任何不等的任何问题。  测试员如果对产品、产品必须与之交互的软件和硬件以及将使用的人越了解，越有可能更快地找出重要问题。应好好研究这些方面的内容。\n跟着程序员走 为程序员提供支持，很可能是测试员使命的关键部分。在测试员测试程序员正在编写或刚刚完成的程序时，测试员的反馈有助于提高程序员的工作效率。程序员交付软件后，应该马上测试；程序员修改代码后，应该马上测试所做的变更。尽可能建立最短、最快的反馈环路。当程序员正在苦苦地思索测试员刚刚发现的程序问题时，测试员又开始寻找更多的程序问题。（对于测试员来说，）理想情况是，程序员为了修改测试员找出的程序问题忙得团团转，使程序员，而不是测试员，成为项目的瓶颈。\n别指望任何人会理解测试，或理解测试员需要什么条件才能搞好测试 让客户了解为了有效地完成测试工作都需要什么条件，完全要靠测试员自己。测试员要受管理层和程序员决策的很大影响。如果他们的计划不明确，或设计出的产品很难测试，测试工作就会很难进行。测试员也许不会得到想要的一切，但是测试员可以向管理层和程序员提供帮助自己的机会。\n管理层和程序员并不是不关心测试或质量，他们也许只是不理解自己的行动会对测试过程产生的影响。测试工作的一个重要部分就是向客户解释测试。测试员的解释就像是流感疫苗，有利于健康而又不那么痛苦，但是疫苗的作用会逐渐衰退，必须一遍又一遍地解释。\n 摘抄自《软件测试经验与教训》\n","date":"2020-06-30","permalink":"https://www.zxye.tk/posts/the-role-of-the-tester/","tags":["testing","book"],"title":"测试员的角色"},{"content":"什么是测试用例 测试用例（Test Case）是为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。是将软件测试的行为活动做一个科学化的组织归纳，目的是能够将软件测试的行为转化成可管理的模式。同时测试用例也是将测试具体量化的方法之一，不同类别的软件，测试用例是不同的。\n通俗的讲：就是把整个测试流程的操作步骤用按照一定的格式用文字描述出来。\n为什么要写测试用例 *测试*用例是测试执行的指导；是测试执行的实体，是测试方法、测试质量、测试覆盖率的重要依据和表现形式；是团队内部交流以及交叉测试的依据，便于测试工作的跟踪管理，包括测试执行的进度跟踪，测试质量的跟踪，以及测试人员的工作量的跟踪和考核；在测试执行工作开展前完成测试用例的编写，可以避免测试工作开展的盲目性；测试用例是说服用户相信产品质量的最佳依据，同时也可以提供给客户作为项目验收的依据。\n1、 理清思路，避免遗漏测试点\n理清思路是我们认为最重要的一点，有的系统本来就是一个大而复杂的项目，我们需要把项目功能细分，根据每一个功能通过编写用例的方式来整理我们测试系统的思路，避免遗漏掉要测试的功能点。\n2、 跟踪测试进度进展\n通过编写测试用例，执行测试用例，我们可以很清楚的知道我们的测试进度，方便跟踪我们的测试进度。\n3、 回归测试\n首先我们的系统不是测一遍就完了的，我们需要在开发环境上测试，测试环境上还要进行回归，其次还有可能涉及到合并测试，而且也有可能会有不同的人在不同的阶段进行测试，那么我们就需要测试用例来规范和指导我们的测试行为。\n4、 历史参考\n在我们所做项目的各个版本中，也许会有很多功能是相同或相近的，我们对这类功能设计了测试用例，便于以后我们遇到类似功能的时候可以做参考依据。\n另外如果产品发布后出现了发布缺陷，测试用例也是分析发布后缺陷的依据之一。\n一、编写用例的重要性\n1.深入了解需求的过程，一个项目立项开始，测试就开始介入，我们从产品的PRD文档、用户交互图，视觉图等相关文档去熟悉产品的各个模块，各个业务流程。或者在产品规划和设计阶段，测试开始熟悉产品。而编写用例的过程中，会充分的思考产品需求的细枝末节，需求的不合理、有矛盾、不明确的地方，还能对产品提出更好的建议，监督产品对需求做出更加详细的设计。整个过程是对需求深入了解的过程，产品的整个印象都在测试脑海里。\n**2.测试执行的指导，**用例编写是把产品需求转换为一种可操作步骤的行为，方便以后作为测试的标准，有步骤有计划的进行测试。如果没有这个标准，会使你的测试过程无计划，无目标，变成一个放任主流的状态，完全没有受控性。这样的产品质量保证显然是空谈。\n**3.规划测试数据的准备，**在我们的实践中测试数据是与测试用例分离的。按照测试用例配套准备一组或若干组测试原始数据，以及标准测试结果。尤其象测试报表之类数据集的正确性，按照测试用例规划准备测试数据是十分必须的。除正常数据之外，还必须根据测试用例设计大量边缘数据和错误数据\n**4.反应测试进度，**测试人员开始按照测试用例的描述测试，每过完一个用例标记完成；这样测试也知道自己做过哪些操作，避免没有目的随机测试。并且通过测试用例的执行条数，大致了解该模块的测试进度。\n**5.举一反三发现潜藏缺陷，**测试人员在执行用例的过程中往往会突然发现当初设计的用例步骤中，还可以做这样一个操作，于是发现了bug，这又体现了测试用例的作用， 帮助发现拓展测试范围，扩大测试覆盖面，发现软件中潜藏的缺陷。\n6.分析缺陷的标准 通过收集缺陷，对比测试用例和缺陷数据库，分析确证是漏测还是缺陷复现。漏测反映了测试用例的不完善，应立即补充相应测试用例，最终达到逐步完善软件质量。而已有相应测试用例，则反映实施测试或变更处理存在问题。\n好用例的标准  https://zhuanlan.zhihu.com/p/94993557 https://zhuanlan.zhihu.com/p/24308453 https://blog.csdn.net/qq_28967695/article/details/73609070 https://yq.aliyun.com/articles/130204 https://zhuanlan.zhihu.com/p/74623927 https://blog.csdn.net/deyili/article/details/6640259 https://zhuanlan.zhihu.com/p/89633142 https://www.jianshu.com/p/d8931aa92b10  好用例的标准\n 是否可以发现Bug  设计测试用例的目的就是为了发现bug，如果bug都发现不了，怎么能称得上是一个好的测试用例呢？\n是否够高效  一个好的测试用例应该不止测试一个测试点，从而减少需要的用例总量。但也不能包含太多不想关的测试点，否则你这个用例就没法测试了，并且给开发的debug造成困难。\n是否够经济  这个测试用例执行起来是否容易，分析和debug是否要花太多代价，都是值得考虑的，毕竟咱也要站在组织的角度来看待测试这个事，公司是为了盈利而做这些事，而不是为了做测试而测试。\n是否有足够的扩展性  主要是考察测试用例在维护时是否要花费很大的代价。\n1、用例覆盖程度\n　毫无疑问，这一点应该是最重要的，无需多说，覆盖率最大化是一套测试用例的最重要评价标准，如果漏测就杯具了。\n2、用例是否已经达到工作量最小化\n　在满足用例覆盖程度最大化的前提下，应该尽量减小执行用例所需要的工作量。这些方面的方法有不少，如条件覆盖，分支覆盖，正交覆盖等方法。面对不同的测试对象，也有不同的方法来保证：对于网页背后的php逻辑，可以通过在网页上测试后，用一些工具比如xdebug来统计代码覆盖率；对于向外提供接口的server，采用的方式就是分析在外面暴露的接口设计用例，大致的通过接口参数来估计一下分支判断的情况。\n3、用例的分类以及描述是否足够清晰\n　用例的分类，在这里是指相同类型的用例是否放在一起了。例如：接口类的用例，参数的取值范围是1-3，但是现在却传入4；数据类用例，状态机现在位于状态2，却要求状态跳转到无法到达的4；逻辑类用例，正常功能的产出等。将相同类型的用例放在一起，有助于理清思路，清楚了解用例设计是否完备。\n　用例的描述，是指描述的清晰程度是否能够形成文档。例如上面参数取值范围的例子，用例这样写：“传入错误的值”或者“传入非1-3的值”，明显没有写成“传入值4”有效。这与写程序一样，总是写闭区间的范围而不是开区间。\n4、用例是否表明了测试目的\n　写明用例的测试目的，对文档的易于理解性和工作交接的好处不言而喻，现代软件工程不可能只有一个人在做事情，项目于人员的变动也是难免的。在过程中留下足够的信息，可以在后续工作提高很多效率。\n5、测试用例的易于维护性\n　如果被测对象有所升级，测试用例的说明或者脚本是不是容易维护呢？例如在有状态机的情况下，测试用例之间是相互依赖的（即需要一定的执行顺序），这样被依赖的用例修改后，后端不需要同步根据修改。而如果用例之间没有相互依赖关系（如用例是自己造的数据，不是依赖于前端的产出），可能一旦有变化，就需要修改这两个。当然，这两种情况不能绝对的说哪种好，是需要看实际使用时候的情况进行取舍的。不过，通过一些系统性的工具支持，也会出现一种做法绝对性的好于另外一种的情况，情况很多，做法也有很多，在这里就不多说了。\n既然测试用例的重要性可想而知，那么用例评审更加重要，用例评审即是对用例的评议和审查，是必须的过程。在工作过程中，对于测试用例的评审，分享几点自己的心得。\n二、用例评审内容\n  是否覆盖测试需求上的所有功能点，不违背产品原型和代码设计，用例设计的结构安排是否清晰合理，有利于高效覆盖需求\n  用例是否具有可执行性，前提条件、执行步骤和预期结果是否正确，有明确的验证方法。优先级安排是否合理\n  是否从用户层面来设计用户使用的场景和业务流程\n  是否包含充分的异常测试用例\n  是否简洁，不冗余，复用性强\n  四、用例评审需要避免\n  测试点含糊用语，每个用例评审都应该确定最终版，稍有矛盾或疑惑的需求点，都应该确认下来，不能含糊不清。\n  杂乱无章的评审，有顺序有逻辑的进行评审是很重要的一点，如果臆想按照自己的思路评审，不顾他人感受，那么就等同于做无用功。这样的用例执行出来也会有一定的质量风险。\n  好的测试用例编写的原则：最低的成本找到最多的问题，最短的路径验证最多的可能\n大概有这几种风格：\n  精简型（每个title和标题内容都基本用一个词语概括了你需要测试的点，起点拨作用）\n  PRD型（把PRD阐述了一遍的样子，内容特别冗余，但是对于开发和产品而言可读性较强，不过不被提倡）\n  操作步骤型（在TC中把自己测试这个系统的操作步骤一步一步的详细写出来，以及所需要造的测试数据和异常步骤。但是这种对于开发只查看部分功能点的TC可读性可操作性较低，对于写作者本身实用性较高，但是后期一旦业务逻辑修改，需要修改的内容较多）\n  TC是测试基础，也是最反映一个测试的思维逻辑和测试思想的地方。\n以下5点可以判断测试用例是不是一个好的测试用例\n1、测试覆盖面全\n覆盖面全，是最最重要的一点，只有全面的覆盖，才能找到最多的问题，只有更全面的测试，才能更好的保障产品的质量，当然穷尽测试是不可能的，所有全面也是相对的。\n2、测试用例精简\n精简的case，是为了减少重复的工作，减少人工成本和时间成功，通过TC设计策略了解和对于需求的充分了解，达到精简测试用例。\n3、步骤清晰\n步骤清晰，主要是为了提高TC的复用型，无论是对于开发还是对于后期的自己都可以看到TC一目了然\n4、目的明确\n冗长的步骤前，用几个字概括你的测试目的，方便阅读\n5、易于维护\n易于维护，分为以下几种维护：\n易于他人维护修改\n易于系统升级维护修改\n易于挑选不同纬度，不同优先级，不同功能的测试用例\n结构清晰、优先级明确、描写清晰的测试用例更容易维护\n想写好测试用例，前提是测试分析和需求拆解做的足够好，通过xmind或者UML图把需求和开发设计提供的产品信息提炼出来。\n我个人的提炼标准一般是：\n  所有业务链路是否是闭环；\n  所有业务场景以用户层面来观察是否合情合理；\n  技术设计是否存在性能/可靠/安全等风险；\n  梳理测试要点，明确每个业务在测试环节里面需要观察的功能预期；\n  开始明确测试方案，确认列出来的测试要点要怎么样才能实施测试。这里多问自己一句：只做功能测试能满足质量覆盖的要求吗？不能就扩展考虑是否做白盒测试/接口测试/性能测试/稳定性测试/安全测试/体验测试/\u0026hellip;；\n  然后才进入测试用例编写的阶段，通过对测试点的特征评估考虑用哪种测试用例设计方法覆盖；\n  最后输出用例。\n  在这里,我想说说我对用例的个人看法：\n  用例不仅仅只是为了满足功能测试，它应该是通过一组输入输出的方式用来衡量产品功能是否符合预期。\n  测试用例不可能永远只被设计者执行，所以请严格按照规范来设计和编写用例，让其他后继的执行人能高效准确的执行。\n  用例设计是极其严肃的任务，但是业内很少QA会真正的做到根据被测试对象的特征来挑选测试用例设计方法并严格按照这些方法来输出用例。\n  如何编写好的用例 三、用例评审过程\n**1. 提前发出初稿和会议邀约，**至少提前一天发出用例初稿，并确定参与用例评审人员，以便项目经理，产品和开发提前阅读用例，让会议更有效率的进行\n**2. 先做简单的业务流程介绍，**这个是在评审开始尤为重要的一个过程，刚开始评审，参与人员会比较蒙圈，产品和开发都不知道测试的思路，或者半途加入新的开发和测试，对需求和业务都不够熟悉，如何让评审快速进入状态，先做简单的需求业务流程介绍，说明白打算如何去做评审。\n【举个栗子】一个项目有用户体系、电子账户、理财、生活模块，可以先由大到小的细分下去；可用事先画好的脑图，各种流程图，也可当场快速写上板书。\n**3. 按模块进行，**有些模块，业务性不是特别强的，可以简单说下有哪些模块，每个模块评审的时候，按测试项分类，UI、核心功能、基础功能、边界测试、兼容测试和异常测试等，预期结果类似的，主要讲清楚用例主题，让参与人员知道每条用例是做什么的。\n**4. 按业务流程进行，**业务流程性较强的需求，需要有业务场景和逻辑，按一定的顺序来，让参与人跟着你的思想，避免东一句西一句，\n【举个栗子】一个理财活期产品的测试用例评审，购买和赎回，跑批时间段分日间和日终，工作日和周末四个场景，按不同场景分为不同的业务流程进行评审，有理有据，逻辑思路清晰。\n**5. 按测试数据进行，**涉及到计算逻辑、收益、报表等需求的，用例编写时会先规划好测试数据，尽管测试数据也是按不同的业务场景来设计的，但直接用测试数据来评审你的测试点，会更清晰，跟上你思路的开发和产品会对应上自己的产品设计和代码设计去评审你的测试点是否不合理或覆盖率不全的地方，从而有效的评审测试用例。\n三、用例评审后的确认\n为了节约时间成本，第一次评审尽量对用例设计全面考虑，提前发现其中的不足之处；但是第一次评审难免会要修修补补的地方，在评审时尽快的修复，不能在一两分钟修复的，记录下来，在会议结束后进行修改，如果改动不是很多的，可以发出邮件，标明修改部分，再最后确认最终版。如果需要进行二次评审，那么重新开始邀约会议做二次评审。\n四、关于提升用例编写能力的一些建议\n 熟悉业务，了解系统  任何系统都有大的业务背景，只要熟悉了业务知识才能更有效的使用系统。\n任何系统在使用过程中，都有一个熟悉的过程，对系统越熟悉，越容易发现系统问题、业务问题。\n学会换位思考，用客观的思考方式站在用户的角度分析问题  作为测试人员如果想提升测试用例的编写能力，首先应该做到的就是站在客户的角度分析客户需要什么和客户想要什么，以及客户不想要什么，也就是所谓的客户的使用场景，这样有利于我们更好的挖掘和思考隐含的需求。至于这个需求该不该做，那是需求人员的职责，这个需求做起来复不复杂那是开发人员的事情，作为测试人员需要考虑的事就是你所设计的正向和反向测试用例是不是用户常用到的场景，以及一些客户基本不会用到的场景有哪些。\n多思考，不要拘束于惯性思维  一个人做一个工作时间越久，经验大概率是会越来越丰富的，但同时，也可能被自己的经验所限制。习惯性的套用经验，活在自己的舒适区，会让自己的成长停滞不前。所以作为一个测试人员如果想要提升自己的测试用例设计能力，一定要多思考，不要被惯性思维束缚，不要被所谓的经验束缚。\n学会利用好网络资源提升自己的能力  提升测试用例设计能力，多思考是非常重要的，但不是让你傻思考。当你的进步遇到瓶颈的时候，不要闭门造车，做井底之蛙，要充分利用网络上的学习资源，学习一些前辈的经验，并把这些运用到实际的测试用例设计中去。山外青山楼外楼，多浏览和关注一些关于测试用例设计的网站或者微信公众号，广开言路，相信会对你的测试用例设计能力的提升会有很大的帮助的。\n善于总结和分享  基于以上四点我们还要做到善于总结，乐于分享，把常见到的用例设计的误区和一些好的用例设计，和用例设计习惯分享给周围的小伙伴，这样可以集众人之所长，不断提升我们的用例设计能力。\n1、要参与需求评审，评审需求的过程实际也是熟悉业务需求的过程。只有对业务比较熟悉了，才能更好的，更充分的设计出高质量的测试用例。\n2、要多阅读文档，其中包括产品策划书、规格说明书、需求文档，接口文档等，我们可以收集一切相关的文档来帮助理解所要测试的产品需要完成的目标。\n3、尽量多参加项目组内的会议。比如需求讨论、设计讨论、计划讨论等会议，这样在讨论过程中也能加深对产品的理解。\n4、要善于沟通，多和客户、开发、测试人员进行沟通。遇到不明确的问题、有疑问的需求，可以咨询项目负责人或者客户等。这样才能提前解决需求理解偏差等。\n5、测试用例名称，也叫测试用例标题，一定要写得简洁、明了，需要用概括的语言描述该用例的出发点和关注点，使得测试人员第一眼看到测试用例名称就能够明白测试用例的目的。用例名称中一般要求不能存在假设性的语句，并且原则上每个用例的名称不能重复。\n6、预置条件要明确，包括测试环境、测试数据、测试场景。因为许多BUG只有在特定的环境、特定的场景下才可以重现。没有正确的前提条件，就无法进行后面的测试步骤或无法得到预期的结果。\n7、测试步骤描述要简单、清晰，并且要清楚每一个步骤的描述，我们平常的鼠标和键盘的每一动作都代表一个操作步骤。比如：第一步，输入用户姓名；第二步，输入登录密码；第三步，用户点击登录。步骤写的明确时就利于提高用例的可操作性。\n8、用例的预期结果要完整而且清晰，并且要将各个输出的结果写出来，包括：返回值的内容、数据库相关字段的记录、界面的响应结果、输出结果的规则符合度、日志的检查和对其它业务影响的检查。\n9、测试用例级别要划分清楚，这样在测试执行时有主次之分。\n10、测试用例的划分也要单一，一个测试用例只检查功能点的一种情况。一个用例检查的情况太多，会导致用例的目的不明确。而且这样组织用例，有利于需求覆盖率的统计。一个功能点我们测试了哪些情况，以及哪些功能点我们在重点测试，一目了然。\n11、评审用例很关键，因为经过测试用例的评审可以发现：用例设计的结构安排是否清晰、合理；是否覆盖所有的需求功能点；是否存在冗余的用例；是否具有很好的可执行性；是否存在对需求理解上的差异等。评审需要项目经理、需求分析人员、架构设计人员、开发人员和测试人员都参与，也需要客户方的开发人员和测试人员。\n12、召开测试用例评审会议，在会议上大家可以提问互答，对模糊不清的地方可以进行讨论。这样可以站在不同的角度，站在很多人的思维和思考方式下设计用例。\n13、站在用户的角度来设计用例，以用户的使用逻辑及操作习惯为出发点，从用户实际可能的操作场景考虑，一定要脱离系统提供功能。\n14、测试用例需要不断更新和维护，不要认为测试用例的设计是一个阶段，测试用例的设计也需要迭代，在软件开发的不同的阶段都要回来重新审视和完善测试用例。并且需要在测试执行时利用发散思维不断的构造和完善测试用例。\n总的来说，写出好的测试用例需要我们不断的积累和完善，需要我们不断的在工作中去总结。写出好的测试用例没有简单的公式或规定可以遵循。即使是多年以来在测试方面感兴趣的人也很难做到这一点。\n三、如何编写用例\n1、测试需求分析，得到测试点\n在测试需求分析阶段，我们只有需求文档，所以编写测试用例的唯一依据就是需求文档，因此在进行用例编写之前一定要进行需求分析，需求分析的主要工作就是：了解需求的整个实现背景、分析需求的合理性、明确需求的范围、挖掘需求文档中隐藏的需求。\n在通过需求交底的过程，确定开发的初步实现思路和方法。随着测试需求分析的深入，列出需求的框架，包括测试范围即各个功能点，测试的场景等，确定一些测试可以提前介入的工作需要说明的是对于需求中的问题一定要记录下来，找需求确认，需求漏掉的或者存在问题的地方，开发和测试更容易漏掉，而且遗漏的需求很有可能会使得项目整体业务逻辑发生变化，一定要及时提前确认。\n2、分析得到用例优先级\n得到了需求的各个测试点后，应该先将这些测试点简单的分配一下优等级，一般分为高中低三个优先级，我认为得到优先级后可以让需求用例的设计更有侧重和着重点。\n3、细化测试点变成可执行case\n根据测试需求分析得到的需求框架，梳理细化测试点，这里的测试点虽然粗，但是不应该有遗漏，这是进行测试点细化的前提。根据测试点，细化出具体的测试用例，要注意各个点的组合测试的情况，还要注意各个测试点的反向测试的情况。\n在细化测试点的时候，我们可以要参考以前写好的公共测试用例，甚至可以直接引用，这样既可以避免一些不必要的时间浪费，但是参考不等于照搬，在引用的同时，也一定要思考本次需求自己特有的测试点。\n另外需要考虑的就是测试点细化到什么程度的问题，也就是一个度的问题，我们要把握好测试点细化的一个度的问题，太粗的测试点没有指导意义，太细的测试点容易让我们纠的太细，忽略整体的测试，反而也起不到一个指导的效果，所以一定要把握好测试点细化的度。\n4、及时更新测试用例\n需求分析和用例编写阶段，是主要的细化用例时间，这段时间的目标是梳理出可指导执行测试的用例，但是需求会有变动，需求会有维护，用例也一样，所以用例是需要持续维护的，所以在需求变动的同时，我们也要及时维护测试用例，否则的话，测试用例很可能成为一个错误的指导。\n另外测试用例完成后就会进入一个用例评审的阶段，在用例评审阶段，会有用例评审人，针对你的用例作出的评审，主要检查你的用例是否有测试点遗漏，场景遗漏，测试case描述模糊，测试结果输出模糊等问题，针对用例评审人提出的问题，我们也要及时的更改我们的用例。\n5、及时维护通用测试用例\n什么是通用测试用例呢？我理解的通用测试用例就是：项目中或者跨项目中很多的公用业务，固化模块，这些功能基本上是趋于稳定不变的，因此可以梳理出通用的比较全面的测试点，作为指导和规范业务和模块的规范，这些生成的规范即通用的测试用例。当我们针对某一模块或者业务持续维护时，就发现我们需要持续维护这的用例，就会发现有些用例业务类似、执行步骤一致、验证项属性一致等等，这个时候通过梳理业务的通用属性，通用用例梳理梳理成章。所以说，通用的测试用例是一个对用例不断维护的产出，因此我们在测试软件维护的过程中一定要及时的更新通用测试用例，对后面的测试和用例维护有一个很大的指导作用。\n","date":"2020-06-23","permalink":"https://www.zxye.tk/posts/how-to-write-good-test-cases/","tags":["testing"],"title":"如何编写好的测试用例"},{"content":"思维混乱，是因为大脑没有结构 请你花10秒钟的时间，记住以下的20个数字：\n好，我们再来试一组数字，还是花10秒钟来记住它：\n其实这2组的20个数字是一样的，但是不是觉得第二组一下子就记住了？\n 为什么会这样？ 因为第二组数据更符合我们大脑的使用习惯，数字与数字之间有清晰的逻辑和结构。\n我们大脑处理信息有2个规律：\n 太多的信息记不住 喜欢有规律的信息  可你有没有遇到过这样的情况：有人口若悬河的和你讲了半天，他说的每个字你都听得懂，然而组合在一起，你并不知道他想说什么，内容没有逻辑，语句没有重点，就像刚才那一串杂乱的数字\u0026hellip;\n听他说话时间一长，你甚至开始头疼，变得焦躁，心里骂到：“你TM到底想说什么\u0026hellip;？”\n你别觉得听着难受，讲的人，他自己也许更难受！\n明明心里有很多想法，甚至做了上百页的PPT，但就是讲不清楚….为什么会这样？\n因为思维没有结构 我们思考问题的时候，脑子里的想法会不断地涌现出来，看似有很多，却杂乱无章，就像是衣橱里的一堆没有整理的衣服，彼此缠绕，互相堆砌在一起。\n当有人问你，你能说说你有哪些衣服吗？\n“嗯\u0026hellip;.我有很多衣服（想法）\u0026hellip;”\n能详细点说吗？ “我有一条蓝裤子，一条橘黄色裙子，一件白衬衫，还有件灰白条纹衬衫，一条牛仔裤，一条蓝色竖条纹的裤子，还有顶黑色的帽子，哦对了，还有一条蓝色裤子（这个刚才好像说过了)…”\n￥#%@#￥%@… 你到底有些啥？\n“我刚才说的都是我有的啊…”\n语言是思维的传声筒\n如果你的思维没有经过整理，就会像这堆乱糟糟的衣服，你拥有他们，却无法理解他们！\n自己看着难受，别人听着难懂！\n那怎么办？如何让思维变得既全面又有序呢？\n你需要结构化思维 所谓结构化思维，就像是把衣橱里的这些衣服，分门别类的整理好。\n比如按季节分类，按穿着场合分类，按服装风格分类等等..\n这时候，别人再问你：你有些什么衣服呢？\n你回答：我一共有208件装备，分为：\n 夏季、春秋季、冬季三大类； 每个季节的衣服又分为工作装、休闲装、宴会装、运动装四大系列； 其中，休闲装里有田园、淑女、简约三种风格； 每种风格的衣服，拥有深色、浅色各3套搭配； 另外配了4双运动鞋，5双皮鞋，6双休闲鞋，7个包包，8顶帽子来应对不同需要..  是不是听着清楚多了？\n并且，当你需要使用这些整理好的衣服时，也会变得很方便。\n比如，今天你想要和男朋友晚上去一个party，那么你不需要再从所有的衣服里翻来覆去的寻找，一件件试穿\u0026hellip;\n而是直接在已经分类好的衣橱中，找到宴会装区域，从里面拿起一套适合的即可。\n把你的想法和思维内容，像整理衣服一样，分门别类的安放好，组成一个结构分明的整体，方便日后的理解、存储、使用。这个，就称之为「结构化思维」\n学会结构化的思维，有什么好处？ 如果你能够习惯用结构化的方式进行思考，你的思维能力，沟通能力，学习能力都将获得大幅度的提升：\n比如，公司的线下门店，生意突然下滑，怎么办？\n如果你不会结构化思维，你可能会这样说\u0026hellip;\n思路清晰，考虑周全。\n再比如，你们公司近期要举办一场大型的相亲活动，你是项目的负责人，目前正在召开项目工作会议，老板请你介绍一下本次活动目前的安排：\n如果你不会结构化思维，你可能会这样表达\u0026hellip;\n是不是感觉整个表达逻辑非常的有序，层次分明？\n除了表达和思考，结构化的能力还能帮助我们提高学习的效率，比如我问你：过去一年，你都学了些啥呢？\n如果你不会结构化思维，你可能会这样回答\u0026hellip;\n怎么样？是不是感觉很不一样呢？\n好，说了那么多结构化思维的好处，那么，我们应该如何才能拥有这种能力呢？\n接下来，我就带你从最基本的地方开始说起，帮助你快速学会结构化思维。\n快速学会结构化思维 有一天，你驾驶着自己的汽车，在路上游荡，汽车突然停下，发生哄哄的巨响，无法行驶，怎么办？\n是哪里出了问题？轮胎？轴承？发动机？油箱？还是有只猫在车里作怪？\n一辆汽车，拥有上万个零件，当你发现汽车的行驶功能出现故障时，如果你不是专业修汽车的，你根本不知道是哪个零件可能出了问题，你能想到的也是这上万零件里的一小部分\u0026hellip;\n那怎么办？ 你一通乱试后，最终无果，只得叫来拖车，将汽车送入了修理厂\u0026hellip;\n师傅一看，说：小问题，你稍等片刻…\n然后咔咔咔，不到一局王者荣耀的时间，就把车给修好了！\n为什么能那么快？\n不是有上万个零件吗？\n如果逐个检查一遍，至少也需要一天的时间啊，这还不算更换和维修的时间！\n师傅为什么能那么快？\n因为：结构！\n在维修师傅的眼中，汽车并不是由上万个零件拼接而成的，而是「结构化」的：\n 有了结构，师傅就能由局部到整体，快速判断可能导致问题的所有区域。 有了结构，师傅就能由混乱到有序，以模块为单位进行整块整组的排查。 有了结构，师傅就能由复杂到简单，将大问题切成多个小问题逐个击破。  透过结构看世界，你就拥有了化繁为简的能力！\n结构化思维，关键就在于「结构」二字，如果你能找到复杂问题背后的结构，就能像修车师傅那样，将问题化繁为简，变成若干个小问题，从而更快速的找到解决方案。\n那么，我们该如何将一个问题结构化呢？\n结构化思考的步骤 第一步 明确目的，找到分解角度 所谓的结构化，是不是就是把问题拆散、切碎，然后再分类汇总就行了？\n比如刚才整理衣服的的例子、汽车零件的例子，就是把一个整体，拆分成一个个小零件，然后根据小零件的属性，进行了分类汇总。\n真的是这样吗？\n并没有那么简单\u0026hellip;\n将一个「整体」拆成一个个独立的「要素」，再将一个个「要素」组合成的结构，其实可以有很多种组合方式。\n比如刚才的汽车零件，你也可以把它们按材质分类，方便垃圾回收；\n或者按生产零件的厂家分类，方便返厂维修；\n或者按头部、身体、四肢的构造分类，就能组合成一个大黄蜂….\n同样的要素，组合成不同的结构，就能实现不同的功能和目的。因此，结构化思维，并不是简单的做个分类汇总，而是分解后，以什么方式组合，要达成什么目的？\n所以，我们得在问题分解之前，先弄清楚分解的目的是什么，然后根据目的进行拆解与结构化。比如说，对于一个项目：\n 如果目标是分析进度：那就按时间进度，过程阶段来分解； 如果目标是分析成本：那就按工作项来分解； 如果目标是分析客户：那就按性别、年龄、学历、职业、收入等来分解。  第二步 按MECE原则，组成结构 确定了分解目的，然后我们就要开始搭建结构了，先说一种最基本的结构形态：金字塔结构。\n什么是金字塔结构？ 简单来说就是：先确认目标问题，再根据分解的目的，将问题分解成不同的类别，类别下再放入对应的不同要素，这样逐层分解，最终的形成类似于金字塔的形状结构。\n并且，金字塔的每一层，都必须牢固，不能少一块砖，也不能多一块砖，不然整个结构就会垮塌，这个就称为MECE原则。\n什么是MECE原则？ MECE是麦肯锡著名咨询师「巴巴拉·明托」在她的著作《金字塔原理》中提出的核心概念，意思是：相互独立、完全穷尽。\n也就是金字塔的每一层，内容不能有重复的部分，也不能有遗漏的部分。\n比如，你把衣服分类为：\n 春秋季服饰 职业套装  这个就有重叠的部分：有些衣服既是职业装，也是春秋季服饰；\n也有遗漏的部分：夏天穿的休闲服应该归到哪一类？\n那么，什么才是不重叠，不遗漏，符合MECE原则的呢？\n你可以按季节分：春秋装，冬装，夏装。\n除了这3类之外，没有其他季节了，这个就是「不遗漏」；春秋的衣服差不多，所以归为一类，夏天的衣服，春秋冬穿不了；冬天的衣服，也不能归类在春夏秋这三个季节里，因此「不重叠」，符合MECE原则。\n是不是有点听晕了？\n不着急，下面我用一个例子来说明：\n问题：如何在未来三个月完成100万销售业绩？\n我们可以通过以下两种方式来构建金字塔结构：\n方式 1自上而下「使用演绎法」设计结构。 要完成100万的业绩，关键是客户，因此我们可以根据客户的类别进行划分，对不同客户类别采取不同的营销策略来完成业绩。\n根据MECE原则我们发现，客户无非来源于三类：\n 陌生的新客户； 正在跟进中的准客户； 已经购买过的老客户；  因此，我们可以在金字塔的第一层，划分为：新客户、跟进中的客户、老客户这三类。\n这样一划分，大致的思路已经清楚了：\n 开拓更多获取新客户的渠道； 提高跟进中客户的付款转化率； 促进老客户的复购；  根据这个策略，我们再继续往每个子分类中添加要素，比如：\n 在新客户下，添加可拓展的新渠道列表； 在准客户下，添加促销方案； 在老客户下，添加老客户回访计划等等\u0026hellip;  如此这般，一层层演化细分，最终形成一个金字塔结构。\n其中，第一层的分类最重要，它决定了你整个结构的整体功能。\n不过，这个分解方式没有标准答案，你在运用的过程中，得根据实际问题，找到对问题的解决最直接有效切分方式，比如：\n 侧重于分而治之的 可以按空间维度进行分类：新客户、跟进中客户、老客户；或者业务A、业务B、业务C； 侧重于进度把控的 可以按时间维度进行分类：第一个月、第二个月、第三个月； 侧重于战略聚焦的 可以按重要程度进行分类：机构客户、普通客户； 侧重于目标达成的 可以按演绎逻辑进行分类：流量、转化率、客单价、复购率；  方式 2自下而上「使用归纳法」提炼结构。 自上而下演绎法的好处是效率高，可以很快速的就把问题结构化。\n可是，这种方式有个前提，就是你得对问题的解决方法有深刻的理解，能够快速找到恰当的分解角度，或者大脑中已经有了现成的结构可以直接使用，比如：销售额 = 流量 × 转化率 × 客单价。\n如果没有现成的结构，或者找不到分解的角度怎么办？\n你可以尝试使用「归纳法」自下而上的提炼结构。具体怎么做？\n  针对问题目标，穷尽所有能想到的内容   我们还是回到前面的问题：\n如何在未来三个月完成100万销售业绩？\n然后你需要开始头脑风暴，把能想到的所有相关信息，不管是建议方法、关键人物、还是重要事项、截止时间等等\u0026hellip;总之，只要和问题相关，有多少写多少，完全穷尽。\n你也可以找来一些帮手，把大伙儿关在会议室里一起讨论，运用群体智慧，通过各种唇枪舌战，各种奇思妙想，将想法、建议、点子铺满整个白板\u0026hellip;\n头脑风暴结束，你发现真的是说什么的都有…\n不过，这都什么跟什么啊，果然是人多智商低\u0026hellip;..\n是不是看着很头大？\n还是不知道接下来该怎么办\u0026hellip;\n别急，我们接着进行下一步\u0026hellip;\n 用归纳法中的「求同、求异、剩余法」对内容进行分组   注：关于归纳法这几个方法可以回看上节课的内容。\n在分组过程中，你需要对内容进行一些增减修补，比如：\n 把一些有明显上下层次关系的先连接起来，看起来比较方便； 把同一分组中明显缺少的项目补上，比如客户分类中缺少「老客户」这一类； 再把一些重复的内容删除，不恰当的内容进行修正；  经过一番调整，凌乱的内容很快被分成了5个大组：渠道、获客方法、产品活动、客户分类、沟通方式，这里的分组名称不要求太精确，因为后期可能还需要调整。\n是不是感觉整体结构清晰很多了？\n不过，这5类之间的逻辑，看上去还是比较混乱，内容之间也不MECE，而且也不是金字塔结构…\n怎么办？\n我们接着进行下一步…\n 梳理逻辑层次，构建金字塔结构   接着，你需要开始梳理这5组的逻辑关系。我们发现，「客户分类」这个组和其他几组明显不同，渠道、获客方式、沟通方式应该是根据不同的客户采取的不同的拉新、促销的手段。\n因此，我们把客户分类这组拎出来，作为金字塔的上一层，把渠道、获客方法、沟通方式，根据客户的类别不同，重新组合，放在金字塔的下层。\n在调整的过程中，继续修改归类错误，结构不MECE的部分，比如：\n 「客户分类」中目前的内容是：新客户，准客户，老客户，机构客户。而机构客户和其他三类有重叠部分，不符合MECE原则，应剔除； 之前的类别命名不精确，其实应该分为「渠道、营销」这2部分，不同的用户对应不同的渠道，不同的渠道对应不同的营销方式； 头脑风暴时只考虑了新客户的渠道，没有考虑准客户和老客户的渠道，要补上\u0026hellip;  这样看上去是不是又清晰很多了？\n咦？「产品活动」去哪了？\n不管是新客户、准客户还是老客户，我们采取的产品活动都是同一个，因此可以把产品活动放在他们的上方，作为金字塔的顶端，这也因此成为了本次3个月业绩冲刺的核心活动。\n现在是不是看到金字塔结构了？\n第三步 调整结构，给出方案 目前这个方案看上去还不太完善。\n因为内容基本都是通过头脑风暴得来的，比较零碎，但是结构已经出来了。\n接下来，我们需要先检查整个结构是否MECE，逻辑层次是否有混淆的部分，调整一下。\n然后，根据这个结构，再往里面继续增减要素，不断完善整个方案。\n注：篇幅原因，就不再继续做深一步的完善工作了，有兴趣的同学可以自己尝试。\n最后，你就可以根据这个金字塔结构，给出未来3个月业绩冲刺的完整方案了：\n你看，这样一步步梳理，我们就从一堆凌乱、没有规则的想法中，提炼出了一套有结构，有逻辑，可执行的行动方案。\n这，就是结构化思维的力量！\n不过，结构化思维的过程，就是将问题分解成一个金字塔结构吗？\n当然不是。\n金字塔结构只是结构化思维中最基本的一种形态，是结构化思维的基础。\n接下来，我将带你进入结构化思维的进阶技巧\u0026hellip;\n结构化思维的进阶技巧 通过刚才的例子我们可以看到，结构化思维，可以将一个复杂的整体，分解成多个小部分来逐个分析，让思维可以细致又不失整体；也可以将零碎的信息分类归档，组合成一个金字塔结构，让思考可以发散又井然有序。\n但是，整个过程既要头脑风暴穷尽想法，又得不断调整逻辑找出恰当的结构，还需要每一层都符合MECE原则\u0026hellip;\n这样下来，耗时就会比较长。而且，万一有些该考虑的部分，因为在头脑风暴的时候没有出现，后来也没想到，导致缺少一整个思考维度，怎么办？\n有没有更高效的方法，可以让你把问题快速结构化，又保证每一步都符合MECE原则呢？\n下面，我就给你说一下结构化思维中的进阶技巧：平面切割法。\n什么是平面切割法？ 你拿出一张白纸放在面前，想象在白纸上即将填满的内容，将构成一个完整的方案。\n然后怎么办？\n念个咒语，答案就会自动出现？\n当然不是。\n你需要拿起一支笔，开始对这个完整的方案，用横、竖线进行切割。只要你画的线是贯穿、封闭的，那么切出来的结构一定是MECE的。\n这个很好理解，因为本来就是一个整体，肯定是无遗漏的；用线条把彼此分开，一定是相互独立不重叠的。\n现在的关键问题是，这个线怎么画？\n当然不能随便画，就像我们中国的汉字，一共有10万个左右，每个字都不一样，但所有的汉字，都是通过「点、横、竖、撇、捺、折、弯、钩」这八个基本的笔画组合而成的。\n切割平面的线也一样，也有两个基本手法，所有的结构都来源于这两个手法的单独或组合使用：\n平面切割的基本手法： 1第一个画线手法：两分法 两分法是指：任何事物都是一对矛盾的统一体，彼此对立，加在一起又是一个整体。比如：有无、是非、黑白、阴阳、虚实、因果….\n因此，如果我们能找到一件事情中，既对立、又统一的两面，我们就能用一条线，将他们彼此分开，组合成一个对立统一体，而他们两者也一定是MECE的。\n比如，你们公司最近想招募新员工，应该采取什么样的招聘策略？\n然后我们就开始思考，这张白纸上就是你所要面对的所有招募对象，是否可以用两分法，将他们分成一个对立统一的整体呢？\n我们想到了一个要素：能力。\n我们可以把他们先分成：能力强、能力弱的两类，彼此对立，结合在一起又是统一的整体，符合MECE。\n不过这个分类还是太宽泛，还有没有能组成对立统一体的其他要素？\n我们又想到了第二个要素：态度。\n我们可以把他们分成态度好、态度差这两类，彼此对立，又能融合统一。\n可是，纸上已经被切割成能力强弱的两部分了，怎么办？\n我们可以横向再画一条线，把纸切成上下两部分，上面的代表态度好，下面的代表态度差。\n这样，纸张就被我们切成了一个二维四象限，4个部分彼此MECE，面试者也因此被我们分成了四类，他们分别是：\n 能力强/态度好 能力强/态度差 能力弱/态度差 能力弱/态度好  有了这个结构，我们就能很方便的制定出对应的招聘策略了：\n注：结构化思考是帮助我们分析问题的，至于分析完之后又应该如何给出更有效的解决方案，还得看你的背景知识量，上面这个案例省略了具体策略的制定过程，有心的同学可以自行思考一下原因。\n当然，遇到问题，你不用每次都自己切割。\n有一些已经成熟的模型，也都是建立在这个切分方法之上的，你可以根据问题，直接拿现成的结构模型使用，不要自己重新发明轮子。\n比如，基于两分法的管理理论：\n比如，将两次两分法，组合成一个二维四象限的各种管理理论：\n当然，还可以找到很多，就不一一列举了，他们都是基于MECE原则，使用了两分法切割出来的结构模型，非常好用。\n学会了这个切割方法后，你自己也能原创出一些有价值的分析结构，说不定还能出本书啥的。\n2第二个画线手法：三分法 三分法，就是在二分法的中间添加一个「过渡」的状态，让分类变的更加的细致，也避免非此即彼的绝对论断。比如：\n 黑、灰、白； 好、一般、差； 事前、事中、事后； 陌生客户、准客户、老客户；  你也能将两个三分法，组合成一个九宫格，比如：\n通用电气矩阵，就是把波士顿矩阵的二分法改成了三分法的变形，分析结构变得更加的细致，战略选择也更加的精准。\n不过，三分法带来结构更细致的同时，也带来了结构的更加复杂，很多人看到这个九宫格就已经蒙圈了。因此，当你还没有熟练掌握结构化思维的前提下，如无必要，尽量避免过多的使用三分法。\n结合这两种画线技巧，你可以设计出更复杂的结构模型。\n比如，让你思维更缜密的「5W2H结构」。\n比如，让你快速理清商业模式的「商业模式画布」\n比如，让你能全面分析企业发展问题的「麦肯锡7S」\n也许，你曾经看到过这些结构模型，也学习过他们的含义，以及使用方法。而通过刚才的学习，你是否能看到他们是如何被一步步切割出来的呢？\n如果你能看到这些结构的演化过程，你是否对他们的理解和使用又更深了一个层次？\n作为思考题，课后你可以自己试着拿张纸推演一遍\n回到前面头脑风暴的案例\n我们试着用平面切割法，看看可以把刚才这个问题切成什么样的结构：\n问题：如何在未来三个月完成100万销售业绩？\n1用两分法，找到第一条切割线\n客户？产品？活动方案？营销？渠道？\n好像这些都不太适合，要么范围太小，无法包含所有相关的信息；要么无法切分成一个对立统一的整体。\n那应该怎么切？\n通过思考后发现，要完成100万销售业绩，无论是从哪个角度思考，无非就分为公司的外部因素和公司的内部因素，这既包含了所有的相关要素，又对立统一。\n因此，我们第一条线可以先把结构分为「内部因素、外部因素」这两部分。\n继续用两分法、三分法切割结构。\n2第二条线怎么画？\n要完成100万销售，无非就2个环节：\n 把产品生产出来； 把产品卖掉；  因此，第二条线可以是「生产与销售」这对对立统一体。\n切割后，出现了一个二维四象限，彼此符合MECE原则。为了便于理解，我们对这4部分进行重新命名：\n 外部销售问题：那就是「营销渠道」的问题 外部生产问题：那就是「市场需求」的问题 内部销售问题：那就是「销售团队」的问题 内部生产问题：那就是「产品设计与供应链」的问题  3然后，再看一下每个部分是否还可以继续切割：\n比如，在「营销渠道」这个分类中，不同的用户类别适用于不同的渠道和营销方式，因此，可以用三分法，切成：新客户、准客户、老客户三类；再横向切成营销和渠道两部分；\n比如，在「销售团队」这个分类中，使用X-Y结构，设置业绩目标，施加外部压力；设置业务奖励，提供内在激励；\n比如，在「市场需求」这个分类中，用两分法，切分为用户需求和市场热点，用于搜集信息，协助设计部门做出更受欢迎的产品或者活动；\n比如，在「产品设计/供应」这个分类中，用两分法，切分为产品设计和供应链管理，针对用户的需求和未来这3个月可能出现的销售高峰，调整产品设计，对供应链进行优化等…\n如果说，前面金字塔结构是一名业务主管的视角，那么当你通过平面切割，你便拥有了CEO的全局视野。\n除了看到前面金字塔结构中的所有和营销相关的内容，你还能看到之前未考虑到的公司内部视角和产品生产视角：\n有了这个结构，你就可以从用户需求、市场热点的部分开始，收集相关信息并加以分析；\n然后，用这些信息指导你的产品设计，活动设置，优化产品供应链；\n接着，设定销售团队的业绩目标，制定团队的激励方案；\n最后，针对不同用户的不同销售渠道，采取不同的营销方式。\n通过平面切割来进行结构化思维，你的整个解决方案，将变得更加的完整和系统！\n还没结束\u0026hellip;\n当方案开始执行，根据实际的销售情况，市场反馈，视图中右下角的「市场需求」部分的信息就会被更新；\n这将进一步帮助你优化产品设计，提供更受市场欢迎的产品，优化供应链的管理，以满足市场的增长；\n紧接着，调整团队业绩目标，优化激励方案；\n然后，继续改善渠道的营销方式…\n随后，又进入下一波优化循环，如此往复\u0026hellip;\n你有没有发现，整个方案动起来了！\n它不再是固定的方案，在纸上一成不变，而是会随着时间推移，不断调整、自我演化的！这种加入了时间轴的动态思考，将我们的思维从三维上升到了四维，进化到了另一种方式\u0026hellip;\n 来源 《思维混乱，是因为大脑没有结构》\n","date":"2020-01-05","permalink":"https://www.zxye.tk/posts/structure-thinking-methods/","tags":["book"],"title":"结构化思维方法"},{"content":"技术人具备“结构化思维”意味着什么? 作者:张建飞 高级技术专家\n 在日常工作中，我们时常会碰到这样的情况，有的人讲事情逻辑非常混乱，罗列了很多事项，却把握不到重点，无法把一件事情说清楚。这种思维混乱是典型的缺少结构化思维的表现。结构化思维非常重要，不仅仅体现在表达上，也体现在在我们分析问题的过程中。具备结构化思维，才能将问题分析地更全面、更深刻。\n 什么是结构化思维? 那么到底是什么是结构化思维呢?简单来说，结构化思维的定义就是:逻辑 + 套路。\n表达要有逻辑 所谓逻辑是指我们的结构之间必须是有逻辑关系的。例如，你说话的时候用“第一、第二、第三”这个逻辑顺序是合理的，但是，用“第一，第二，第四”就会显得很奇怪。当然，即使你用了”一、二、三”，也不一定就意味着你的内容有逻辑关系。\n想让内容有逻辑关系，我们要学会四种组织思想的逻辑关系:\n1)演绎(因果)顺序:“大前提、小前提、结论”的演绎推理方式就是演绎顺序。\n比如，经典三段论:所有人都要死，苏格拉底是人，苏格拉底要死。\n2)时间(步骤)顺序:“第一、第二、第三”，“首先、然后、再者”等，很多的时间顺序同时也是因果顺序。\n3)空间(结构)顺序:“前端、后端、数据”，“波士顿、纽约、华盛顿”，化整为零(将整体分解为部分)等都是空间顺序。\n4)程度(重要性)顺序:比如“最重要、次重要、不重要”等。 实际上，所有的逻辑关系都在这四种顺序之内。只要我们的思想和表达在这四种逻辑顺序之内，就是有逻辑的，否则就会显得没有逻辑性。\n做事要有套路 套路是指我们解决问题的方法论，这个也非常重要。比如，5W2H 分析法就是一个非常好的，可以帮助我们分析问题的一个”套路”。试想一下，面对任何一个问题，你都能从 Why、Who、When、Where、What、How 和 How much(如下图所示)，七个方面去思考。是不是比不知道这个方法论的人，用点状的思考，5W2H 分析法就全面得多。\n图片来源:https://www.toutiao.com/i6619057728725729800/\n例如，我们在对问题域进行分析和领域知识提炼的时候，就可以用上 5W2H。 5W2H 模型给出了具有指导意义的约束，要求我们提炼的领域知识必须具备模型的六个要素。这就好比两位侃侃而谈的交谈者，因为有了确定的主题与话题边界，一场本来是漫无目的野鹤闲云似的闲聊就变成了一次深度交流的专题高端对话。\n逻辑是一种能力，而套路是方法论，是经验。逻辑是道的东西，而方法论是术的东西。二者都很重要，只有熟练的掌握二者我们才能更好的进行结构化思考。\n如何进行结构化思考? 逻辑性和方法论是结构化思维的底层，那么如何进行结构化思考呢?这也是有方法论的，总的来说是有两个步骤，首先是“建立中心”，然后再进行“分解”。\n建立中心 建立中心也就是要定义清楚要解决的问题，要明确目标。是我们结构的顶层节点，也是一种以终为始的思考方式。也就是说，我们首先要搞清楚 why，然后再进行 how。\n★ 建立中心有两种方式:\n  自上而下:适用于问题比较明确的情况，我们只需要找到问题的核心要素即可，然后进行展开即可。\n  自下而上:对于问题不够明确的情况，我们需要对多种杂乱的内容，进行分类、剪枝、归纳汇总成一个中心。 建立中心通常不会是一次成型的，随着对问题理解的变化，对中心的抽象也会进行相应的调整。不同的抽象层次其面对的问题宽度是不一样的。具体要用哪个层次的抽象作为“中心”，要视具体情况而定。\n  比如面对“系统 bug 多”的问题，向上抽象是“提升代码质量”，向下抽象是 “加强测试”，都可以作为中心，选择哪个为中心取决于你当前要解决的问题是什么。\n结构化分解 确定完中心之后，我们需要构建一个结构，使用结构化的思维对问题进行分解。 分解的策略就是我们上文提到的四种逻辑顺序，即演绎顺序、时间顺序、空间顺序和程度顺序。\n在做空间分解的时候，要注意满足 MECE(Mutually Exclusive Collectively Exhaustive，相互独立，完全穷尽)原则。\n比如我们要对衣服进行分类，如果按照季节和风格进行分类，就会出现互相重叠，并且不能穷尽的情况，也就不满足 MECE。这种分类是逻辑混乱的。\n图片来源:https://www.toutiao.com/i6619057728725729800/\n我们可以按季节分:春秋装，冬装，夏装。除了这 3 类之外，没有其他季节了， 这个就是「不遗漏」。\n图片来源:https://www.toutiao.com/i6619057728725729800/\n结构化思维应用 如何落地新团队? 想象这样一个场景，你刚刚入职一家新公司，或者转岗到一个新团队，作为一个技术人，你将如何落地开展你的工作呢?\n这里，我们就能用上结构化思维来帮我们理清思路，从而有条不紊的开展工作了。我们要知道对一个企业来说，核心要素无外乎就是业务、技术和人，也就是说这三个要素是我们要建立的中心。基于这个中心，我们可以进行进一步拆解，形成子结构。然后对子结构再进行分析找到应对策略。这样一步步递进，我们就已经在用结构化思维解决如何落地新团队的问题了。\n★ 1. 熟悉业务 1)了解产品:任何一个团队都有自己要负责的产品，申请一个测试账号去用一下产品，是熟悉产品比较好的方式。\n2)了解流程:任何业务都有自己的业务流程，而业务流里面最核心的是信息流。 我们可以通过人员采访，了解关键节点的信息输入和信息输出;可以画一些泳道活动图，理清楚系统的主要角色，以及他们之间的交互关系。\n3)客户走访:通过走访客户，我们可以更加获得业务的第一手资料，更加贴近业务和客户诉求。\n★ 2. 熟悉技术 1)了解系统架构:可以让团队的技术人员介绍下他们当初系统设计和架构的思路。\n2)了解领域模型:查看关键的核心表结构和系统 API，这样可以快速了解系统的领域模型。\n3)了解代码结构:下载系统工程，熟悉整个工程结构和模块职责。以一个最重要的流程为入手点，阅读代码，看清楚核心的执行逻辑。做一个小需求，掌握相关的流程和权限。\n★ 3. 熟悉人 1)了解组织结构:查看公司的组织树，知道公司大概是如何运作的，以及哪些是KP(Key Person，关键人)。比如，一个典型的电商公司会包括产品部、运营部、销售部、技术部、人力资源部、财务部、法务部等。\n2)了解人员角色:了解公司都有哪些岗位，以及各岗位的职责范围。\n3)拜山头:找到和自己工作息息相关的岗位人员，比如产品和运营。积极和他们沟通，向他们请教业务问题，多多交流。这样一方面可以建立更好的人际关系，另一方面也可以更快地熟悉业务。\n打造极客文化 我最近刚刚转岗到新部门，新部门的老板抛给我一个命题:如何帮助技术团队打造极客文化?\n这个问题的中心很明确，接下来，看看我是如何使用结构化思维来解这个问题的。首先我们从空间顺序进行分解，也就是打造极客文化，我们可以去做哪些事情。\n空间顺序分解确定完要做的事情，我们还可以按照时间顺序对如何落地这些事情进行分解。\n这样把按照这两个维度进行结构化拆解的方案给到老板，老板就会很清晰地知道你的规划和落地策略了。\n如何做晋升述职 作者在阿里巴巴已经做了好几年的晋升评委，发现很多同学都缺乏结构化思维，冗长的 PPT 里，却不能把价值说清楚，不能把推导过程说清楚。实际上，我们需要有一些方法论来指导我们进行关键述职。接下来，我主要说一下述职中存在的两个典型问题:“罗列事情”和“价值的背后”。\n★ 1. 罗列事情 对自己做过的事情进行简单罗列，也许你的确做了不少事情。但是不能体现你对问题思考的深度和做这个事情带来的价值。这样的述职很难打动评委，更结构化的表达应该是:“提出问题，定义问题，分析问题，解决问题，最后是展望未来”。这是一个经典的表述问题的结构，也是麦肯锡推荐的问题解决的框架。\n类似的框架还有 zoom in/zoom out。我们说事情时，应该像电影镜头一样，先从远拉近，再由近拉远。zoom in 是先从宏观背景开始，首先让大家知道你的事情发生的背景，为什么这事重要?然后讲到具体细节，怎么做成的?解决了什么问题?背后的思考是什么?最后 Zoom out，再从细节调回到整体，结果是什么，带来的客户价值是什么，你对未来的思考是什么。\n★ 2. 价值的背后 把价值说清楚的确很重要，正所谓:路走对了，就不怕远。如果你连价值都不明确，后面做的再多也是白搭。但是，仅仅阐述价值也是不够的，会让人觉得你有邀功之嫌。\n比如你说:“我主导研发的风控系统把公司的坏账率从 5% 降低到 2%”。这样的表述是不够的，你还需要把价值背后的过程和思考说清楚。对于这个结果，评委可能会问:\n 之前为什么那么高? 为什么你的方法可以降低?是如何归因的? 具体解决了什么问题? 是否可以总结出一套办法，以后别人也能用这个办法解决这些问题?  如果你在评委提问之前，就能对这些问题进行深入思考和适当呈现。那么你就是既有结果又有过程了。\n通过这些案例，我们可以看到具备结构化思维，可以帮助我们快速的理清处理问题的思路，提升工作效率。经常锻炼结构化思维，可以极大的提升我们职场竞争力， 让工作有条不紊，事半功倍。\n 参考资料: 《思维混乱，是因为大脑没有结构》 来源 技术人具备“结构化思维”意味着什么?\n","date":"2020-01-04","permalink":"https://www.zxye.tk/posts/structure-thinking/","tags":["book"],"title":"结构化思维"},{"content":"黑盒测试用例设计方法 黑盒测试用例设计方法包括等价类划分法、边界值分析法、错误推导法、因果图法、判定表驱动法、正交试验设计法、功能图法、场景图法等。\n（一）等价类划分法 定义：等价类划分法是把所有可能输入的数据，即程序的输入域划分为若干部分（子集），然后从每一个子集中选取少数具有代表性的数据作为测试用例。等价类方法是一种重要的、常用的黑盒测试用例设计方法。\n等价类是指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的，并合理地假定：测试某等价类的代表值就等于对这一类其他值的测试，因此，可以把全部输入数据合理划分为若干等价类，在每一个等价类中取一个数据作为测试的输入条件就可以用少量代表性的测试数据取得较好的测试结果。等价类划分有两种不同的情况：有效等价类和无效等价类。\n有效等价类，是指对于程序的规格说明来说是合理的、有意义的输入数据构成的集合。利用有效等价类可检验程序是否实现了规格说明所规定的功能和性能。\n无效等价类，指对程序的规格说明是不合理的或无意义的输入数据所构成的集合。对于具体的问题，无效等价类至少应有一个，也可能多个。\n划分标准：  完备测试、避免冗余 划分等价类重要的是：集合的划分、划分为互不相交的一组子集，而子集的并是整个集合 并是整个集合：备性 子集互不相交：保证一种形式的无冗余性 同一类中标识（选择）一个测试用例，同一等价类中，往往处理相同，相同处理映射到“相同的执行路径”。  划分方法：   在输入条件规定了取值范围或值的个数的情况下，则可以确立一个有效等价类和两个无效等价类。如：输入值是学生成绩，范围是0~100\n  在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可确立一个有效等价类和一个无效等价类：\n  在输入条件是一个布尔量的情况下，可确定一个有效等价类和一个无效等价类。布尔量是一个二值枚举类型, 一个布尔量具有两种状态: true 和 false 。\n  在规定了输入数据的一组值（假定n个），并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和一个无效等价类。\n例：输入条件说明学历可为：专科、本科、硕士、博士四种之一，则分别取这四种的四个值作为四个有效等价类，另外把四种学历之外的任何学历作为无效等价类。\n  在规定了输入数据必须遵守的规则情况下，可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）；\n  在确知已划分的等价类中各元素在程序处理中的方式不同的情况下，则应在将该等价类进一步的划分为更小的等价类。\n   转化为测试用例： 在确立了等价类后，可建立等价类表，列出所有划分出的等价类输入条件：有效等价类、无效等价类，然后从划分出的等价类中按以下三个原则设计测试用例：\n 为每一个等价类规定一个唯一的编号； 设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖地有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止； 设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止。  实例1：三角形问题 某程序规定：“输入三个整数a、b、c分别作为三边的边长构成三角形。通过程序判定所构成的三角形的类型，当此三角形为一般三角形、等腰三角形、等边三角形时，分别做计算。。。”用等价类划分方法为该程序进行测试用例设计。\n分析题目中给出和隐含的对输入条件的要求：\n（1）整数 （2）三个数（3）非零数（4）正数\n（5）两边之和大于第三边（6）等腰 （7）等边\n如果a、b、c满足条件（1）~（4），则输出下列四种情况之一：\n 如果不满足条件（5），则程序输出为“非三角形” 如果三条边相等即满足条件（7），则程序输出为“等边三角形” 如果只有两条边相等，及满足条件（6），则程序输出为“等腰三角形” 如果三条边都不相等，则程序输出为“一般三角形”  列出等价类表并编号 覆盖有效等价类的测试用例：\na b c覆盖等价类号码\n覆盖无效等价类的测试用例：\n覆盖有效等价类的测试用例：\na b c覆盖等价类号码\n覆盖无效等价类的测试用例：\n实例2，NextDate NextDate函数包含三个变量：month、day、year，函数的输出为输入日期后一天的日期。\n例如，输入2006年3月7日，则函数的输出为2006年3月8日。要求输入变量month、day、year均为整数值，并且满足下列条件：\n  1＜＝month＜＝12\n  1＜＝day\u0026lt;=31\n  1812\u0026lt;=year\u0026lt;=2012\n  有效等价类为：\nM1=｛月份：1\u0026lt;=月份\u0026lt;=12｝ D1= {日期：1\u0026lt;=日期\u0026lt;=31} Y1=｛年份：1812\u0026lt;=年\u0026lt;=2012｝\n  若条件1~3中任何一个条件失效，则NextDate函数都会产生一个输出，指明相应的变量超出取值范围，比如“month的值不在12范围中”。显然还存在这大量的year、month、day的无效组合，NextDate函数将这些组合作为统一的输出：“无效输入日期”。\n  其无效等价类为：\nM2=｛月份：月份\u0026lt;1｝ M3=｛月份：月份\u0026gt;12｝ D2=｛日期：日期\u0026lt;1｝ D3=｛日期：日期\u0026gt;31｝ Y2=｛年份：年\u0026lt;1812｝ Y3=｛年份：年\u0026gt;2012｝  弱一般等价类测试用例\n强一般等价类测试用例同弱一般等价类测试用例\n注：弱有单缺陷假设；健壮考虑了无效值。\n（一）弱健壮等价类测试\n（二）强健壮等价类测试\n（二）边界值分析法 定义：边界值分析法就是对输入或输出的边界值进行测试的一种黑盒测试方法。通常边界值分析法是作为对等价类划分法的补充，这种情况下，其测试用例来自等价类的边界。\n与等价类区别：  边界值分析不是从某等价类中随便挑一个作为代表，而是使这个等价类的每个边界都要作为测试条件。 边界值分析不仅考虑输入条件，还要考虑输出空间产生的测试情况。  分析方法： 大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部。因此针对各种边界情况设计测试用例，可以查出更多的错误。使用边界值分析方法设计测试用例，首先应确定边界情况。通常输入和输出等价类的边界，就是应着重测试的边界情况。应当选取正好等于，刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据。\n常见边界值：  对16Bit的整数而言，32767和32768是边界 屏幕上光标在最左上、最右下位置 报表的第一行和最后一行 数组元素的第一个和最后一个 循环的第0次、第1次和倒数第2次、最后一次  边界值分析： 1. 边界值分析使用与等价类划分法相同的划分 只是边界值分析假定错误更多地存在于划分的边界上，因此在等价类的边界上以及两侧的情况设计测试用例。\n例：测试计算平方根的函数 输入：实数 输出：实数  规格说明：当输入一个0或比0大的数的时候，返回其正平方根；当输入一个小于0的数时，显示错误信息“平方根非法，输入值小于0”并返回0；库函数printLine可以用来输出错误信息。\n2. 等价类划分： ​\ti. 可以考虑做出如下划分：\n​\tA、输入(i)\u0026lt;0 和(ii)\u0026gt;=0 ​\tB、输出(a)\u0026gt;=0和(b)Error\n​\tii. 测试用例有两个\n​\tA、输入4，输出2.对应(ii)和(a)。 ​\tB、输入10，输出0和错误提示。对应与(i)和(b)\n3. 边界值分析 划分(ii)的边界为0和最大正实数；划分(i)的边界为最小负实数和0.由此得到一下测试用例：\n​\tA、输入｛最小负实数｝ ​\tB、输入｛绝对值很小的负数｝ ​\tC、输入0 ​\tD、输入｛绝对值很小的正数｝ ​\tE、输入｛最大正实数｝\n4. 通常情况下 软件测试所包含的边界检验有几种类型：数字、字符、位置、重量、大小、速度、方位、尺寸、空间等。\n5. 相应地 以上类型的边界值应该在：最大/最小、首位/末位、上/下、最快/最慢、最高/最低、最短/最长、空/满等情况下。\n6. 利用边界值作为测试数据 7. 内部边界值分析 在多数情况下，边界值条件是基于应用程序的功能设计而需要考虑的因素，可以从软件的规格说明或常识中得到，也是最终用户可以很容易发现问题的。然而，在测试用例设计过程中，某些边界值条件是不需要呈现给用户的，或者说用户是很难注意到的，但同时确实属于检验范畴内的边界条件，称为内部边界值条件或子边界值条件。\n内部边界值条件主要有下面几种： ​\t1）数值的边界值检验：计算机是基于二进制进行工作的，因此，软件的任何数值运算都有一定的范围限制。\n​\t2）字符的边界值检验：在计算机软件中，字符也是很重要的表示元素，其中ASCII和Unicode是常见的编码方式。下表中列出了一些常用字符对应的ASCII码值。\n​\t3）其它边界值检验：在不同的行业应用领域，依据硬件和软件的标准不同而具有各自特定的边界值。如下列出部分手机相关的边界值：\n转化为测试用例：  如果输入条件规定了值的范围,则应取刚达到这个范围的边界的值,以及刚刚超越这个范围边界的值作为测试输入数据。  例如，如果程序的规格说明中规定：\u0026ldquo;重量在10公斤至50公斤范围内的邮件，其邮费计算公式为……\u0026quot;。作为测试用例，我们应取10及50，还应取10.01,49.99,9.99及50.01等。\n如果输入条件规定了值的个数,则用最大个数,最小个数,比最小个数少一,比最大个数多一的数作为测试数据。  例如，一个输入文件应包括1~255个记录，则测试用例可取1和255，还应取0及256等。\n将规则1）和2）应用于输出条件，即设计测试用例使输出值达到边界值及其左右的值。  例如，某程序的规格说明要求计算出\u0026quot;每月保险金扣除额为0至1165.25元\u0026rdquo;，其测试用例可取0.00及1165.24、还可取一0.01及1165．26等。\n再如一程序属于情报检索系统，要求每次\u0026quot;最少显示1条、最多显示4条情报摘要\u0026quot;，这时我们应考虑的测试用例包括1和4，还应包括0和5等。\n 如果程序的规格说明给出的输入域或输出域是有序集合,则应选取集合的第一个元素和最后一个元素作为测试用例。\n  如果程序中使用了一个内部数据结构，则应当选择这个内部数据结构的边界上的值作为测试用例。\n  分析规格说明,找出其它可能的边界条件。\n  实例1，批阅试卷 现有一个学生标准化考试批阅试卷,产生成绩报告的程序。其规格说明如下:程序的输入文件由一些有80个字符的记录组成,如右图所示，所有记录分为3组：\n 标题：这一组只有一个记录，其内容为输出成绩报告的名字。 试卷各题标准答案记录：每个记录均在第80个字符处标以数字\u0026quot;2\u0026quot;。该组的第一个记录的第1至第3个字符为题目编号（取值为1一999）。第10至第59个字符给出第1至第50题的答案（每个合法字符表示一个答案）。该组的第2，第3……个记录相应为第51至第100，第101至第150，…题的答案。 每个学生的答卷描述：该组中每个记录的第80个字符均为数字\u0026quot;3\u0026quot;。每个学生的答卷在若干个记录中给出。如甲的首记录第1至第9字符给出学生姓名及学号，第10至第59字符列出的是甲所做的第1至第50题的答案。若试题数超过50，则第2，第3……纪录分别给出他的第51至第100，第101至第150……题的解答。然后是学生乙的答卷记录。 学生人数不超过200，试题数不超过999。 程序的输出有4个报告：  ​\ta)按学号排列的成绩单，列出每个学生的成绩、名次。 ​\tb)按学生成绩排序的成绩单。 ​\tc)平均分数及标准偏差的报告。 ​\td)试题分析报告。按试题号排序，列出各题学生答对的百分比。\n解答：分别考虑输入条件和输出条件，以及边界条件。给出下表所示的输入条件及相应的测试用例。\n输出条件及相应的测试用例表。\n实例2，三角形的边界问题分析测试用例 在三角形问题描述中，除了要求边长是整数外，没有给出其它的限制条件。在此，我们将三角形每边边长的取范围值设值为[1, 100]。\n实例3，NextDate函数边界值分析测试用例\n在NextDate函数中，隐含规定了变量mouth和变量day的取值范围为1≤mouth≤12和1≤day≤31，并设定变量year的取值范围为1912≤year≤2050。\n（三）错误推导法 定义：基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法。\n基本思想：列举出程序中所有可能有的错误和容易发生错误的特殊情况,根据他们选择测试用例。\n  例如,输入数据和输出数据为0的情况；输入表格为空格或输入表格只有一行。这些都是容易发生错误的情况。可选择这些情况下的例子作为测试用例。\n  例如，前面例子中成绩报告的程序，采用错误推导法还可补充设计一些测试用例：\n 程序是否把空格作为回答 在回答记录中混有标准答案记录 除了标题记录外，还有一些的记录最后一个字符即不是2也不是3 有两个学生的学号相同 试题数是负数    例如，测试一个对线性表（比如数组）进行排序的程序，可推测列出以下几项需要特别测试的情况：\n 输入的线性表为空表； 表中只含有一个元素； 输入表中所有元素已排好序； 输入表已按逆序排好； 输入表中部分或全部元素相同。    例如，测试手机终端的通话功能，可以设计各种通话失败的情况来补充测试用例：\n 无SIM 卡插入时进行呼出（非紧急呼叫） 插入已欠费SIM卡进行呼出 射频器件损坏或无信号区域插入有效SIM卡呼出 网络正常，插入有效SIM卡，呼出无效号码（如1、888、333333、不输入任何号码等） 网络正常，插入有效SIM卡，使用“快速拨号”功能呼出设置无效号码的数字    （四）因果图法 定义：因果图法是一种利用图解法分析输入的各种组合情况，从而设计测试用例的方法，它适合于检查程序输入条件的各种组合情况。\n应用： 等价类划分法和边界值分析方法都是着重考虑输入条件，但没有考虑输入条件的各种组合、输入条件之间的相互制约关系。这样虽然各种输入条件可能出错的情况已经测试到了，但多个输入条件组合起来可能出错的情况却被忽视了。\n如果在测试时必须考虑输入条件的各种组合，则可能的组合数目将是天文数字，因此必须考虑采用一种适合于描述多种条件的组合、相应产生多个动作的形式来进行测试用例的设计，这就需要利用因果图（逻辑模型）。\n1. 因果图介绍  4种符号分别表示了规格说明中向4种因果关系。   因果图中使用了简单的逻辑符号，以直线联接左右结点。左结点表示输入状态（或称原因），右结点表示输出状态（或称结果）。\n  C1表示原因，通常置于图的左部；e1表示结果，通常在图的右部。C1和e1均可取值0或1，0表示某状态不出现，1表示某状态出现。\n  2. 因果图涉及的概念  关系  ​\t恒等：若c1是1，则e1也是1；否则e1为0。 ​\t非：若c1是1，则e1是0；否则e1是1。 ​\t或：若c1或c2或c3是1，则e1是1；否则e1为0。“或”可有任意个输入。 ​\t与：若c1和c2都是1，则e1为1；否则e1为0。“与”也可有任意个输入。\n约束  输入状态相互之间还可能存在某些依赖关系，称为约束。例如,某些输入条件本身不可能同时出现。输出状态之间也往往存在约束。在因果图中,用特定的符号标明这些约束。\n输入条件的约束有以下4类：\n​\t· E约束（异）：a和b中至多有一个可能为1，即a和b不能同时为1。 ​\t· I约束（或）：a、b和c中至少有一个必须是1，即 a、b 和c不能同时为0。 ​\t· O约束（唯一）；a和b必须有一个，且仅有1个为1。 ​\t· R约束（要求）：a是1时，b必须是1，即不可能a是1时b是0。\n输出条件约束类型\n输出条件的约束只有M约束（强制）：若结果a是1，则结果b强制为0。\n3. 采用因果图法设计测试用例的步骤：  分析软件规格说明描述中,那些是原因(即输入条件或输入条件的等价类),那些是结果(即输出条件),并给每个原因和结果赋予一个标识符。 分析软件规格说明描述中的语义，找出原因与结果之间,原因与原因之间对应的关系，根据这些关系,画出因果图。 由于语法或环境限制,有些原因与原因之间,原因与结果之间的组合情况不可能出现，为表明这些特殊情况,在因果图上用一些记号表明约束或限制条件。 把因果图转换为判定表。 把判定表的每一列拿出来作为依据,设计测试用例。  实例1，字符 某软件规格说明书包含这样的要求：第一列字符必须是A或B，第二列字符必须是一个数字，在此情况下进行文件的修改，但如果第一列字符不正确，则给出信息L；如果第二列字符不是数字，则给出信息M。\n解答：\n 根据题意，原因和结果如下：  原因：\n​\t1——第一列字符是A； ​\t2——第一列字符是B； ​\t3——第二列字符是一数字。\n结果：\n​\t21——修改文件； ​\t22 ——给出信息L； ​\t23——给出信息M。\n其对应的因果图如下：  11为中间节点；考虑到原因1和原因2不可能同时为1，因此在因果图上施加E约束。\n根据因果图建立判定表。  表中8种情况的左面两列情况中，原因①和原因②同时为1，这是不可能出现的，故应排除这两种情况。表的最下一栏给出了6种情况的测试用例，这是我们所需要的数据。\n实例2，自动售货机 有一个处理单价为5角钱的饮料的自动售货机软件测试用例的设计。其规格说明如下：若投入5角钱或1元钱的硬币，押下〖橙汁〗或〖啤酒〗的按钮，则相应的饮料就送出来。若售货机没有零钱找，则一个显示〖零钱找完〗的红灯亮，这时在投入1元硬币并押下按钮后，饮料不送出来而且1元硬币也退出来；若有零钱找，则显示〖零钱找完〗的红灯灭，在送出饮料的同时退还5角硬币。\n 分析这一段说明，列出原因和结果  原因：\n​\t1——售货机有零钱找 ​\t2——投入1元硬币 ​\t3——投入5角硬币 ​\t4——押下橙汁按钮 ​\t5——押下啤酒按钮\n结果：\n​\t21——售货机〖零钱找完〗灯亮 ​\t22——退还1元硬币 ​\t23——退还5角硬币 ​\t24——送出橙汁饮料 ​\t25——送出啤酒饮料\n画出因果图，如图所示。所有原因结点列在左边，所有结果结点列在右边。建立中间结点，表示处理的中间状态。中间结点：  ​\t11—— 投入1元硬币且押下饮料按钮 ​\t12——押下〖橙汁〗或〖啤酒〗的按钮 ​\t13——应当找5角零钱并且售货机有零钱找 ​\t14——钱已付清\n转换成判定表：  在判定表中，阴影部分表示因违反约束条件的不可能出现的情况，删去。第16列与第32列因什么动作也没做，也删去。最后可根据剩下的16列作为确定测试用例的依据。  （五）判定表驱动法 定义：判定表是分析和表达多逻辑条件下执行不同操作的情况的工具。\n优点：能够将复杂的问题按照各种可能的情况全部列举出来，简明并避免遗漏。因此，利用判定表能够设计出完整的测试用例集合。在一些数据处理问题当中，某些操作的实施依赖于多个逻辑条件的组合，即：针对不同逻辑条件的组合值，分别执行不同的操作。判定表适合于处理这类问题。\n阅读指南，判定表：\n判定表由四部分组成，如下图：\n​\t1) 条件桩（Condition Stub）：列出了问题的所有条件。通常认为列出的条件的次序无关紧要。 ​\t2) 动作桩（Action Stub）：列出了问题规定可能采取的操作。这些操作的排列顺序没有约束。 ​\t3) 条件项（Condition Entry）：列出针对它左列条件的取值。在所有可能情况下的真假值。 ​\t4) 动作项（Action Entry）：列出在条件项的各种取值情况下应该采取的动作。\n规则及规则合并：\n​\t1） 规则：任何一个条件组合的特定取值及其相应要执行的操作称为规则。在判定表中贯穿条件项和动作项的一列就是一条规则。显然判定表中列出多少组条件取值，也就有多少条规则，既条件项和动作项有多少列。 ​\t2） 化简：就是规则合并有两条或多条规则具有相同的动作，并且其条件项之间存在着极为相似的关系。\n合并举例：\n​\t1) 如下图左端，两规则动作项一样，条件项类似，在1、2条件项分别去Y、N时，无论条件3取何值，都执行同一操作。即要执行的动作与条件3无关。于是可合并。“-”表示与取值无关 ​\t2) 与上类似，下图中，无关条件项“-”可包含其他条件项取值，具有相同动作的规则可合并。 ​\t3) 化简后的读书指南判定表\n判定表建立步骤： ​\t1） 确定规则的个数。假如有n个条件，每个条件有两个取值（0，1），故2n种规则。 ​\t2） 列出所有的条件桩和动作桩 ​\t3） 填入条件项 ​\t4） 填入动作项，等到初始判定表 ​\t5） 简化，合并相似规则（相同动作）\n实例1，机器维修 问题要求：“。。。。。。对功率大于50马力的机器，维修记录不全或已运行10以上的机器，应给予优先的维修处理。。。。。。”，这里假定，“维修记录不全”和“优先维修处理”均已在别处有更严格的定义。请建立判定表。\n解答：\n​\t1、确定规则的个数：这里有3个条件，每个条件有两个取值，故应有222=8种规则。 ​\t2、列出所有的条件桩和动作桩：\n​\t3、填入条件项。可从最后1行条件项开始，逐行向上填满。 ​\t4、填入动作桩和动作项。这样便得到如下图的初始判定表\n​\t5、初始判定表化简。合并相似规则后得到\n实例2，NextData函数的精简决策表 M1＝{月份， 每月有30天} M2＝{月份， 每月有31天} M3＝{月份， 2月} 有29＝512条规则 D1＝{日期，1～28} 12月末31日和其它31 D2＝{日期，29} 日月份的31日处理不同 D3＝{日期，30} 平年2月28日处理不同 D4＝{日期，31} 于2月27日 Y1＝{年：年是闰年} Y2＝{年：年不是闰年}  改进为：\nM1＝{月份： 每月有30天} M2＝{月份： 每月有31天， 12月除外} M4＝{月份：12月} M3＝{月份： 2月} D1＝{日期：1\u0026lt;=日期\u0026lt;=27} D2＝{日期：28} D3＝{日期：29} D4＝{日期：30} D5＝{日期：31} Y1＝{年：年是闰年} Y2＝{年：年不是闰年}  输入变量间存在大量逻辑关系的NextData决策表\n用决策表测试法测试以下程序：该程序有三个输入变量month、day、year（month、day和year均为整数值，并且满足：1≤month≤12和1≤day≤31），分别作为输入日期的月份、日、年份，通过程序可以输出该输入日期在日历上隔一天的日期。  例如，输入为2004年11月29日，则该程序的输出为2000年12月1日。\n​\t1) 分析各种输入情况，列出为输入变量month、day、year划分的有效等价类。 ​\t2) 分析程序规格说明，结合以上等价类划分的情况给出问题规定的可能采取的操作（即列出所有的动作桩）。 ​\t3) 根据（1）和（2），画出简化后的决策表。\n案例分析如下： ​\t? month变量的有效等价类： ​\tM1: {month=4,6,9,11} M2: {month=1,3,5,7,8,10} ​\tM3: {month=12 }M4: {month=2} ​\t? day变量的有效等价类： ​\tD1:{1≤day≤26} D2: {day=27} D3: {day=28} D4: {day=29} D5: {day=30} D6: {day=31} ​\t? year变量的有效等价类： ​\tY1: {year是闰年} Y2: {year不是闰年}  ​\t4) 考虑各种有效的输入情况，程序中可能采取的操作有以下六种：\n​\ta1: day+2 a2: day=2 a3: day=1\n​\ta4: month+1 a5: month=1 a6: year+1\n 判定表在功能测试中的应用\n 一些软件的功能需求可用判定表表达得非常清楚，在检验程序的功能时判定表也就成为一个不错的工具。如果一个软件的规格说明指出：  ​\t? 当条件1和条件2满足，并且条件3和条件4不满足，或者当条件1、3和条件4满足时，要执行操作1。\n​\t? 在任一个条件都不满足时，要执行操作2。\n​\t? 在条件1不满足，而条件4被满足时，要执行操作3。 根据规格说明得到如下判定表：\n  这里，判定表只给出了16种规则中的8种。事实上，除这8条以外的一些规则是指当不能满足指定的条件，执行3种操作时，要执行1个默许的操作。在没必要时，判定表通常可略去这些规则。但如果用判定表来设计测试用例，就必须列出这些默许规则（如下表）。\n默许的规则\n​\t2. 判定表的优点和缺点\n​\t? 优点：它能把复杂的问题按各种可能的情况一一列举出来，简明而易于理解，也可避免遗漏。 ​\t? 缺点：不能表达重复执行的动作，例如循环结构。\n​\t3. B. Beizer 指出了适合使用判定表设计测试用例的条件：\n​\t? 规格说明以判定表形式给出,或很容易转换成判定表。 ​\t? 条件的排列顺序不会也不影响执行哪些操作。 ​\t? 规则的排列顺序不会也不影响执行哪些操作。 ​\t? 每当某一规则的条件已经满足,并确定要执行的操作后,不必检验别的规则。 ​\t? 如果某一规则得到满足要执行多个操作,这些操作的执行顺序无关紧要。\nB. Beizer提出这5个必要条件的目的是为了使操作的执行完全依赖于条件的组合。其实对于某些不满足这几条的判定表，同样可以借以设计测试用例，只不过尚需增加其它的测试用例罢了。\n（六）正交试验法 定义：从大量的（实验）数据（测试例）中挑选适量的,有代表性的点（例）,从而合理地安排实验（测试）的一种科学实验设计方法.类似的方法有:聚类分析方法,因子方法方法等.\n利用正交实验设计测试用例的步骤：\n1. 提取功能说明,构造因子\u0026ndash;状态表 把影响实验指标的条件称为因子.而影响实验因子的条件叫因子的状态.利用正交实验设计方法来设计测试用例时,首先要根据被测试软件的规格说明书找出影响其功能实现的操作对象和外部因素,把他们当作因子,而把各个因子的取值当作状态.对软件需求规格说明中的功能要求进行划分,把整体的概要性的功能要求进行层层分解与展开,分解成具体的有相对独立性的基本的功能要求.这样就可以把被测试软件中所有的因子都确定下来,并为确定个因子的权值提供参考的依据.确定因子与状态是设计测试用例的关键.因此要求尽可能全面的正确的确定取值,以确保测试用例的设计作到完整与有效。\n2. 加权筛选,生成因素分析表 对因子与状态的选择可按其重要程度分别加权.可根据各个因子及状态的作用大小,出现频率的大小以及测试的需要,确定权值的大小。\n3. 利用正交表构造测试数据集 正交表的推导依据Galois理论（这里省略,需要时可查数理统计方面的教材）。\n利用正交实验设计方法设计测试用例,比使用等价类划分,边界值分析,因果图等方法有以下优点:节省测试工作工时；可控制生成的测试用例数量；测试用例具有一定的覆盖率。\n（七）功能图法 定义：功能图由状态迁移图和布尔函数组成.状态迁移图用状态和迁移来描述.一个状态指出数据输入的位置（或时间）,而迁移则指明状态的改变.同时要依靠判定表或因果图表示的逻辑功能.例,一个简化的自动出纳机ATM的功能图。\n应用：\n1. 功能图介绍 一个程序的功能说明通常由动态说明和静态说明组成.动态说明描述了输入数据的次序或转移的次序.\n静态说明描述了输入条件与输出条件之间的对应关系.对于较复杂的程序,由于存在大量的组合情况,因此,仅用静态说明组成的规格说明对于测试来说往往是不够的.必须用动态说明来补充功能说明.功能图方法是用功能图FD形式化地表示程序的功能说明,并机械地生成功能图的测试用例.\n功能图模型由状态迁移图和逻辑功能模型构成.状态迁移图用于表示输入数据序列以及相应的输出数据.在状态迁移图中,由输入数据和当前状态决定输出数据和后续状态.逻辑功能模型用于表示在状态中输入条件和输出条件之间的对应关系.逻辑功能模型只适合于描述静态说明,输出数据仅由输入数据决定.测试用例则是由测试中经过的一系列状态和在每个状态中必须依靠输入/输出数据满足的一对条件组成.功能图方法其实是是一种黑盒白盒混合用例设计方法。\n（功能图方法中,要用到逻辑覆盖和路径测试的概念和方法,其属白盒测试方法中 的内容.逻辑覆盖是以程序内部的逻辑结构为基础的测试用例设计方法.该方法要求测试人员对程序的逻辑结构有清楚的了解.由于覆盖测试的目标不同,逻辑覆盖可分为:语句覆盖,判定覆盖,判定-条件覆盖,条件组合覆盖及路径覆盖.下面我们指的逻辑覆盖和路径是功能或系统水平上的,以区别与白盒测试中的程序内部的.）\n2. 测试用例生成方法 从功能图生成测试用例,得到的测试用例数是可接受的. 问题的关键的是如何从状态迁移图中选取测试用例. 若用节点代替状态,用弧线代替迁移,则状态迁移图就可转化成一个程序的控制流程图形式.问题就转化为程序的路径测试问题（如白盒测试）问题了.\n3. 测试用例生成规则 为了把状态迁移（测试路径）的测试用例与逻辑模型（局部测试用例）的测试用例组合起来,从功能图生成实用的测试用例,须定义下面的规则.在一个结构化的状态迁移（SST）中,定义三种形式的循环:顺序,选择和重复.但分辨一个状态迁移中的所有循环是有困难的.（其表示图形省略）。\n4. 从功能图生成测试用例的过程  生成局部测试用例:在每个状态中,从因果图生成局部测试用例.局部测试用例由原因值（输入数据）组合与对应的结果值（输出数据或状态）构成。 测试路径生成:利用上面的规则（三种）生成从初始状态到最后状态的测试路径。 测试用例合成:合成测试路径与功能图中每个状态中的局部测试用例.结果是初始状态到最后状态的一个状态序列,以及每个状态中输入数据与对应输出数据的组合。  5. 测试用例的合成算法:采用条件构造树. （八）场景图法 定义：现在的软件几乎都是用事件触发来控制流程的，事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果就形成事件流。这种在软件设计方面的思想也可以引入到软件测试中，可以比较生动地描绘出事件触发时的情景，有利于测试设计者设计测试用例，同时使测试用例更容易理解和执行。\n应用： 基本流和备选流：如下图所示，图中经过用例的每条路径都用基本流和备选流来表示，直黑线表示基本流，是经过用例的最简单的路径。备选流用不同的色彩表示，一个备选流可能从基本流开始，在某个特定条件下执行，然后重新加入基本流中（如备选流1和3）；也可能起源于另一个备选流（如备选流2），或者终止用例而不再重新加入到某个流（如备选流2和4）。\n9.3. 实例  例子描述  下图所示是ATM例子的流程示意图。\n场景设计：下表所示是生成的场景。  注：为方便起见，备选流3和6（场景3和7）内的循环以及循环组合未纳入上表。\n用例设计  对于这7个场景中的每一个场景都需要确定测试用例。可以采用矩阵或决策表来确定和管理测试用例。下面显示了一种通用格式，其中各行代表各个测试用例，而各列则代表测试用例的信息。本示例中，对于每个测试用例，存在一个测试用例ID、条件（或说明）、测试用例中涉及的所有数据元素（作为输入或已经存在于数据库中）以及预期结果。\n表3-9 测试用例表\n数据设计  一旦确定了所有的测试用例，则应对这些用例进行复审和验证以确保其准确且适度，并取消多余或等效的测试用例。\n测试用例一经认可，就可以确定实际数据值（在测试用例实施矩阵中）并且设定测试数据，如表3-10所示。\n表3-10 测试用例表\n测试用例设计综合策略 各种测试方法的综合使用策略：  在任何情况下都必须使用边界值分析方法，经验表明用这种方法设计出测试用例发现程序错误的能力最强。 必要时用等价类划分方法补充一些测试用例。 用错误推导法再追加一些测试用例。 对照程序逻辑，检查已设计出的测试用例的逻辑覆盖程度，如果没有达到要求的覆盖标准，应当再补充足够的测试用例。 如果程序的功能说明中含有输入条件的组合情况，则一开始就可选用因果图法。  测试用例的设计步骤  构造根据设计规格得出的基本功能测试用例； 边界值测试用例； 状态转换测试用例； 错误猜测测试用例； 异常测试用例； 性能测试用例； 压力测试用例。  优化测试用例的方法  利用设计测试用例的8种方法不断的对测试用例进行分解与合并； 采用遗传算法理论进化测试用例； 在测试时利用发散思维构造测试用例；  白盒测试用例设计方法 白盒测试常见的用例设计方法有：代码检查法、静态结构分析法、静态质量度量法、逻辑覆盖法、基本路径覆盖测试法、域测试、符号测试。\n（一）代码检查法 代码检查包括桌面检查、代码审查和走查等，主要检查代码和设计的一致性，代码对标准的遵循、可读性，代码逻辑表达的正确性，代码结构的合理性等方面；发现违背程序编写标准的问题，程序中不安全、不明确和模糊的部分，找出程序中不可移植部分、违背程序编程风格的内容，包括变量检查、命名和类型审查、程序逻辑审查、程序语法检查和程序结构检查等内容。\n代码检查方法： 1、代码检查法 （1）桌面检查 这是一种传统的检查方法，由程序员检查自己编写的程序。程序员在程序通过编译之后，对源程序代码进行分析、检验，并补充相关文档，目的是发现程序中的错误。由于程序员熟悉自己的程序及其程序设计风格，桌面检查由程序员自己进行可以节省很多的检查时间，但应避免主观片面性\n（2）代码审查 由若干程序员和测试员组成一个审查小组，通过阅读、讨论和争议，对程序进行静态分析的过程。代码审查分两步：第一步，小组负责人提前把设计规格说明书、控制流程图、程序文本及有关要求、规范等分发给小组成员，作为审查的依据。小组成员在充分阅读这些材料后，进入审查的第二步，召开程序审查会。在会上，首先由程序员逐句简介程序的逻辑。在此过程中，程序员或其他小组成员可以提出问题，展开讨论，审查错误是否存在。实践表明，程序员在讲解过程中能发现许多原来自己没有发现的错误，而讨论和争议则促进了问题的暴露。\n在会前，应当给审查小组每个成员准备一份常见错误的清单，把以往所有可能发生的常见错误罗列出来，供与会者对照检查，以提高审查的失效。这个常见的错误清单也成为检查表，它把程序中可能发生的各种错误进行分类，对每一类错误列出尽可能多的典型错误，然后把它们制成表格，供再审查时使用\n（3）走查 与代码审查基本相同，分为两步，第一步也是把材料分给走查小组的每个成员，让他们认真研究程序，然后再开会。开会的程序与代码审查不同，不是简单地读程序和对照错误检查表进行检查，而是让与会者“充当”计算机，即首先由测试组成员为所测试程序准备一批有代表性的测试用例，提交给走查小组。走查小组开会，集体扮演计算机角色，让测试用例沿程序的逻辑运行一遍，随时记录程序的踪迹，供分析和讨论用。\n人们借助测试用例的媒介作用，对程序的逻辑和功能提出各种疑问，结合问题开展热烈的讨论和争议，能够发现更多的问题。\n代码检查应在编译和动态测试之前进行，在检查前，应准备好需求描述文档、程序设计文档、程序的源代码请当、代码编译标准和代码缺陷检查表等。在实际使用中，代码检查能快速找到缺陷，发现30%～70%的逻辑设计和编码缺陷，而且代码检查看到的问题本身而非征兆。但是代码检查非常耗费时间，而且代码检查需要知识和经验的积累。代码检查可以使用测试软件进行自动化测试，以利于提高测试效率，降低劳动强度，或者使用人工进行测试，以充分发挥人力的逻辑思维能力\n2、代码检查项目 变量交叉引用表；标号的交叉引用表；检查子程序、宏、函数；等价性检查；常量检查；标准检查；风格检查；比较控制流；选择、激活路径；补充文档\n根据检查项目可以编制代码规则、规范和检查表等作为测试用例，如编码规范、代码检查规范、缺陷检查表等\n3、编码规范 编码规范是指程序编写过程中必须遵循的规则，一般会详细制定代码的语法规则、语法格式等\n4、代码检查规范 在代码检查中，需要依据被测软件的特点，选用适当的标准与规则规范。在使用测试软件进行自动化代码检查时，测试工具一般会内置许多的编码规则。在自动化测试基础上使用桌面检查、代码走查、代码审查等人工检查的方法仔细检查程序的结构、逻辑等方面的缺陷\n5、缺陷检查表 在进行人工代码检查时，代码缺陷检查表是我们用到的测试用例。\n代码缺陷检查表中一般包括容易出错的地方和在以往的工作中遇到的典型错误\n（二）静态结构分析法 程序的结构形式是白盒测试的主要依据。研究表明程序员38%的时间花费在理解软件系统上，因为代码以文本格式被写入多重文件中，这是很难阅读理解的，需要其它一些东西来帮助人们阅读理解，如各种图表等，而静态结构分析满足了这样的需求。\n在静态结构分析中，测试者通过使用测试工具分析程序源代码的系统结构、数据结构、内部控制逻辑等内部结构，生成函数调用关系图、模块控制流图、内部文件调用关系图、子程序表、宏和函数参数表等各类图形图标，可以清晰地标识整个软件系统的组成结构，使其便于阅读和理解，然后可以通过分析这些图标，检查软件有没有存在缺陷或错误。\n其中函数调用关系图通过应用程序中各函数之间的调用关系展示了系统的结构。通过查看函数调用关系图，可以检查函数之间的调用关系是否符合要求，是否存在递归调用，函数的调用曾是是否过深，有没有存在独立的没有被调用的函数。从而可以发现系统是否存在结构缺陷，发现哪些函数是重要的，哪些是次要的，需要使用什么级别的覆盖要求\u0026hellip;\u0026hellip;\n模块控制流图是与程序流程图相类似的由许多节点和连接节点的边组成的一种图形，其中一个节点代表一条语句或数条语句，边代表节点间控制流向，它显示了一个函数的内部逻辑结构。模块控制流图可以直观地反映出一个函数的内部逻辑结构，通过检查这些模块控制流图，能够很快发现软件的错误与缺陷\n（三）静态质量度量法 根据ISO/IEC 9126质量模型作为基础，我们可以构造质量度量模型，用于评估软件的各个方面。该模型从上到下分为3层：质量因素（Factors）、分类标准（Criteria）和度量规则（metrics）。其中质量因素对应ISO 9126质量模型的质量特性，分类标准对应ISO 9126质量模型的子特性，度量规则用于规范软件的各种行为属性。以下例子按照可维护性进行分析。\n1、度量规则 度量规则使用了代码行数、注释频度等参数度量软件的各种行为属性\n2、分类标准 软件的可维护性采用以下四个分类标准来评估：可分析性（ANALYZABILITY）、可修改性（CHANGEABILITY）、稳定性（STABILITY）、可测性（TESTABILITY）。每个分类标准由一系列度量规则组成，各个规则分配一个权重，由规则的取值与权重值计算出每个分类标准的取值。\nfunction_TESTABILITY_DRCT_CALLS+LEVL+PATH+PARA\n3、质量因素 质量因素的取值与分类标准的计算方式类似：依据各分类标准取值组合权重方法计算.\nfunction_MAINTAINABILITY=function_ANALYZABILITY\n+function_CHANGEABILITY\n+function_ATABILITY\n+function_TESTABILITY\n（四）逻辑覆盖法 逻辑覆盖是以程序内部的逻辑结构为基础的设计测试用例的技术。\n根据覆盖目标的不同和覆盖源程序语句的详尽程度，逻辑覆盖又可分为：\n 语句覆盖(SC) 判定覆盖(DC) 条件覆盖(CC) 条件/判定覆盖(CC) 条件组合覆盖(MCC) 修正判定条件覆盖(MCDC) 点覆盖 边覆盖 路径覆盖  几种逻辑覆盖标准发现错误的能力呈由弱至强的变化。\n下面我们来逐一举例详解：\n1语句覆盖（SC）： 语句覆盖是指选择足够的测试用例，使得运行这些测试用例时，被测程序的每一个语句至少执行一次，其覆盖标准无法发现判定中逻辑运算的错误.\n我们看下面的被测试代码：\nint foo(int a, int b) { return a / b; }  假如我们的测试人员编写如下测试案例：\nTeseCase: a = 10, b = 5\n测试人员的测试结果会告诉你，他的代码覆盖率达到了100%，并且所有测试案例都通过了。然而遗憾的是，我们的语句覆盖率达到了所谓的100%，但是却没有发现最简单的 Bug，比如，当我让b=0时，会抛出一个除零异常。\n简言之，语句覆盖，就是设计若干个测试用例，运行被测程序，使得每一可执行语句至少执行一次。这里的“若干个”，意味着使用测试用例越少越好。\n语句覆盖率的公式可以表示如下：\n语句覆盖率=可执行的语句总数/被评价到的语句数量 x 100%\n2判定覆盖(DC) 判定覆盖是设计足够多的测试用例，使得程序中的每一个判断至少获得一次“真”和一次“假”，即使得程序流程图中的每一个真假分支至少被执行一次。\n但若程序中的判定是有几个条件联合构成时，它未必能发现每个条件的错误。\n例：\nint a,b; if(a || b) 执行语句1 else 执行语句2  要达到这段程序的判断覆盖,我们采用测试用例:\n1)a = true , b = false; 2)a = false, b = false  3条件覆盖(CC) 条件覆盖是指选择足够的测试用例，使得运行这些测试用例时，判定中每个条件的所有可能结果至少出现一次，但未必能覆盖全部分支.\n例：\nint a,b; if(a || b) 执行语句1 else 执行语句2  要达到这段程序的条件覆盖,我们采用测试用例:\n1)a = true , b = false; 2)a = false, b = true  4判定/条件覆盖（CDC） 判定/条件覆盖是使判定中每个条件的所有可能结果至少出现一次，并且每个判定本身的所有可能结果也至少出现一次。\n例：\nint a,b; if(a || b) 执行语句1 else 执行语句2  要达到这段程序的判定/条件覆盖,我们采用测试用例:\n1)a = true , b = true; 2)a = false, b = false  5条件组合覆盖（MCC） 选择足够的测试用例，使得每个判定中条件的各种可能组合都至少出现一次。显然，满足“条件组合覆盖”的测试用例是一定满足“判定覆盖”、“条件覆盖”和“判定/条件覆盖”的。\n例：\nint a,b; if(a || b) 执行语句1 else 执行语句2  要达到这段程序的判定/条件覆盖,我们采用测试用例:\n1)a = true , b = true; 2)a = false, b = false 3)a = true, b = false 4)a = false, b = ture  6修正判定条件覆盖（MC/DC） MC/DC首先要求实现条件覆盖、判定覆盖，在此基础上，对于每一个条件C，要求存在符合以下条件的两次计算：\n 条件C所在判定内的所有条件，除条件C外，其他条件的取值完全相同； 条件C的取值相反； 判定的计算结果相反。  核心意思是每个条件都要独立影响判定结果。为什么说“两次计算”，而不是“两个用例”呢？当循环中有判定时，一个用例下同一判定可能被计算多次，每次的条件值和判定值也可能不同，因此，一个用例就可能完成循环中判定的MC/DC。\nMC/DC是条件组合覆盖的子集。条件组合覆盖要求覆盖判定中所有条件取值的所有可能组合，需要大量的测试用例，实用性较差。MC/DC具有条件组合覆盖的优势，同时大幅减少用例数。满足MC/DC的用例数下界为条件数+1，上界为条件数的两倍，例如，判定中有三个条件，条件组合覆盖需要8个用例，而MC/DC需要的用例数为4至6个。如果判定中条件很多，用例数的差别将非常大，例如，判定中有10个条件，条件组合覆盖需要1024个用例，而MC/DC只需要11至20个用例。\n下面是MC/DC的示例：\n代码：\nint func(BOOL A, BOOL B, BOOL C) { if(A \u0026amp;\u0026amp; (B || C)) return 1; return 0; }  用例：\n对于条件A，用例1和用例2，A取值相反，B和C相同，判定结果分别为1和0；\n对于条件B，用例1和用例3，B取值相反，A和C相同，判定结果分别为1和0；\n对于条件C，用例3和用例4，C取值相反，A和B相同，判定结果分别为0和1。\n9路径覆盖（PC） MC/DC被称为“最严格的标准”，但这种说法是将条件组合覆盖和路径覆盖排除在外为基础的。MC/DC显然不如条件组合覆盖严格，但是条件组合覆盖需要太多用例，实际应用中难以做到，所以排除，那么，路径覆盖是否也难以做到？使用先进的工具，对于一般的代码，实现路径覆盖还是可能的。另外，路径代表了从函数入口到出口的所有可能的代码组合，这些组合会不会出问题？只有路径覆盖能发现，这与MC/DC侧重于判定内的条件的组合关系是完全不同的。\nＭC/DC与路径覆盖的侧重点不同，两者都有其优势和局限性，如果组合起来，优势互补，形成“MC/DC-路径覆盖”，就是真正意义上的“最严格的标准”了。\n有些程序，路径数量可能大得惊人，可用以下规则和方法减少路径数量：\n计算路径时，不考虑循环的次数，将循环结构视为循环体“至少执行一次”和“从不执行”两个分支；\n不考虑条件的计算结果只考虑判定的计算结果，条件间的组合关系由条件覆盖、C/DC和MC/DC负责；\n一个分支如果不可达，通过该分支的所有路径也不可达，可以让工具自动排除；\n当代码很复杂时，理想的处置方式是将部分代码独立为函数，如果做不到，可以让工具来模拟，即在逻辑结构图中，将部分代码临时屏蔽，被屏蔽的代码视为一个函数调用。交替屏蔽可以既减少路径数量，又保证路径覆盖的效果。\n对于一般复杂度的代码，采用以上规则和方法后，路径数量和用例数量可以维持在一个现实可覆盖的的范围内。\n路径覆盖的主要缺陷是：不相关的逻辑块会组合出大量没有意义的路径。一个函数的路径，可能达到几万条甚至几百万条。如果路径超过100条，通常路径覆盖就没有意义了。对于一般企业来说，建议用MC/DC作为统一的覆盖标准，只有特别关键的代码，才要求完成“MC/DC-路径覆盖”。\n路径覆盖要求设计足够多的测试用例，在白盒测试法中，覆盖程度最高的就是路径覆盖，因为其覆盖程序中所有可能的路径。\n对于比较简单的小程序来说，实现路径覆盖是可能的，但是如果程序中出现了多个判断和多个循环，可能的路径数目将会急剧增长，以致实现路径覆盖是几乎不可能的。\n（五）基本路径测试法 基本路径测试法是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。\n设计出的测试用例要保证在测试中程序的语句覆盖100%，条件覆盖100%。\n在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例。包括以下4个步骤和一个工具方法：\n1.程序的控制流图：描述程序控制流的一种图示方法。\n2.程序圈复杂度：McCabe复杂性度量。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界。\n3.导出测试用例：根据圈复杂度和程序结构设计用例数据输入和预期结果。\n4.准备测试用例：确保基本路径集中的每一条路径的执行。\n工具方法： 图形矩阵：是在基本路径测试中起辅助作用的软件工具，利用它可以实现自动地确定一个基本路径集。\n程序的控制流图：描述程序控制流的一种图示方法。\n圆圈称为控制流图的一个结点，表示一个或多个无分支的语句或源程序语句\n流图只有二种图形符号：\n图中的每一个圆称为流图的结点，代表一条或多条语句。\n流图中的箭头称为边或连接，代表控制流\n任何过程设计都要被翻译成控制流图。\n如何根据程序流程图画出控制流程图?\n在将程序流程图简化成控制流图时，应注意：\n  在选择或多分支结构中，分支的汇聚处应有一个汇聚结点。\n  边和结点圈定的范围叫做区域，当对区域计数时，图形外的区域也应记为一个区域。\n  如下图所示\n如果判断中的条件表达式是由一个或多个逻辑运算符 (OR, AND, NAND, NOR)连接的复合条件表达式，则需要改为一系列只有单条件的嵌套的判断。  例如：\nif a or b x else y  对应的逻辑为：\n独立路径：至少沿一条新的边移动的路径\n基本路径测试法的步骤：\n第一步：画出控制流图 流程图用来描述程序控制结构。可将流程图映射到一个相应的流图(假设流程图的菱形决定框中不包含复合条件)。在流图中，每一个圆，称为流图的结点，代表一个或多个语句。一个处理方框序列和一个菱形决测框可被映射为一个结点，流图中的箭头，称为边或连接，代表控制流，类似于流程图中的箭头。一条边必须终止于一个结点，即使该结点并不代表任何语句(例如：if-else-then结构)。由边和结点限定的范围称为区域。计算区域时应包括图外部的范围。\n画出其程序流程图和对应的控制流图如下\n第二步：计算圈复杂度 圈复杂度是一种为程序逻辑复杂性提供定量测度的软件度量，将该度量用于计算程序的基本的独立路径数目，为确保所有语句至少执行一次的测试数量的上界。独立路径必须包含一条在定义之前不曾用到的边。\n有以下三种方法计算圈复杂度：\n流图中区域的数量对应于环型的复杂性;\n给定流图G的圈复杂度V(G)，定义为V(G)=E-N+2，E是流图中边的数量，N是流图中结点的数量;\n给定流图G的圈复杂度V(G)，定义为V(G)=P+1，P是流图G中判定结点的数量。\n第三步：导出测试用例 根据上面的计算方法，可得出四个独立的路径。(一条独立路径是指，和其他的独立路径相比，至少引入一个新处理语句或一个新判断的程序通路。V(G)值正好等于该程序的独立路径的条数。)\n路径1：4-14 路径2：4-6-7-14 路径3：4-6-8-10-13-4-14 路径4：4-6-8-11-13-4-14  根据上面的独立路径，去设计输入数据，使程序分别执行到上面四条路径。\n第四步：准备测试用例 为了确保基本路径集中的每一条路径的执行，根据判断结点给出的条件，选择适当的数据以保证某一条路径可以被测试到，满足上面例子基本路径集的测试用例是：\n举例说明： 例：下例程序流程图描述了最多输入50个值(以–1作为输入结束标志)，计算其中有效的学生分数的个数、总分数和平均值。\n步骤1：导出过程的流图。 步骤2:确定环形复杂性度量V(G)： 1)V(G)= 6 (个区域)\n2)V(G)=E–N+2=16–12+2=6\n其中E为流图中的边数，N为结点数;\n3)V(G)=P+1=5+1=6\n其中P为谓词结点的个数。在流图中，结点2、3、5、6、9是谓词结点。\n步骤3：确定基本路径集合(即独立路径集合)。 于是可确定6条独立的路径：\n路径1：1-2-9-10-12 路径2：1-2-9-11-12 路径3：1-2-3-9-10-12 路径4：1-2-3-4-5-8-2… 路径5：1-2-3-4-5-6-8-2… 路径6：1-2-3-4-5-6-7-8-2…  步骤4：为每一条独立路径各设计一组测试用例，以便强迫程序沿着该路径至少执行一次。 1)路径1(1-2-9-10-12)的测试用例：\n​\tscore[k]=有效分数值，当k \u0026lt; i ;\n​\tscore[i]=–1, 2≤i≤50;\n​\t期望结果：根据输入的有效分数算出正确的分数个数n1、总分sum和平均分average。\n2)路径2(1-2-9-11-12)的测试用例：\n​\tscore[ 1 ]= – 1 ;\n​\t期望的结果：average = – 1，其他量保持初值。\n3)路径3(1-2-3-9-10-12)的测试用例：\n​\t输入多于50个有效分数，即试图处理51个分数，要求前51个为有效分数;\n​\t期望结果：n1=50、且算出正确的总分和平均分。\n4)路径4(1-2-3-4-5-8-2…)的测试用例：\n​\tscore[i]=有效分数，当i\u0026lt;50;\n​\tscore[k]\u0026lt;0， k\u0026lt; i ;\n​\t期望结果：根据输入的有效分数算出正确的分数个数n1、总分sum和平均分average。\n连接权为“1”表示存在一个连接，在图中如果一行有两个或更多的元素“1”，则这行所代表的结点一定是一个判定结点，通过连接矩阵中有两个以上(包括两个)元素为“1”的个数，就可以得到确定该图圈复杂度的另一种算法。\n（六）域测试法 域测试是一种基于程序结构的测试方法，基于对程序输入空间（域）的分析，选择测试点进行测试。\n域测试主要测试如下错误：\n  域错误：程序的控制流存在错误，对于某一特定的输入可能执行的是一条错误路径，这种错误称为路径错误，也叫做域错误。\n  计算型错误：对于特定输入执行的路径正确，但赋值语句的错误导致输出结果错误，称为计算型错误。\n  丢失路径错误：由于程序中的某处少了一个判定谓词而引起的丢失路径错误。\n  （七）符号测试 符号测试的基本思想是允许程序的输入不仅仅是具体的数值数据，而且包括符号值，符号值可以是基本的符号变量值，也可以是符号变量值的表达式。\n接口测试用例实际\n设计思路\n1) 优先级\u0026ndash;针对所有接口 ​\t1、暴露在外面的接口，因为通常该接口会给第三方调用；\n​\t2、供系统内部调用的核心功能接口；\n​\t3、供系统内部调用非核心功能接口；\n2) 优先级\u0026ndash;针对单个接口 ​\t1、正向用例优先测试,逆向用例次之(通常情况，非绝对)；\n​\t2、是否满足前提条件 \u0026gt; 是否携带默认参值参数 \u0026gt; 参数是否必填 \u0026gt; 参数之间是否存在关联 \u0026gt; 参数数据类型限制 \u0026gt;参数数据类型自身的数据范围值限制\n3) 设计分析 通常，设计接口测试用例需要考虑以下几个方面：\n1、是否满足前提条件 有些接口需要满足前置条件，才可成功获取数据。常见的，需要登陆Token。\n逆向用例：\n针对是否满足前置条件(假设为n个条件)，设计0~n条用例\n2、是否携带默认值参数 正向用例：\n带默认值的参数都不填写、不传参，必填参数都填写正确且存在的“常规”值，其它不填写，设计1条用例；\n3、业务规则、功能需求 这里根据实际情况，结合接口参数说明，可能需要设计n条正向用例和逆向用例\n5、参数是否必填 逆向用例：\n针对每个必填参数，都设计1条参数值为空的逆向用例\n4、参数之间是否存在关联 有些参数彼此之间存在相互制约的关系\n逆向用例：\n根据实际情况，可能需要设计0~n条用例\n5、参数数据类型限制 逆向用例：\n针对每个参数都设计1条参数值类型不符的逆向用例\n6、参数数据类型自身的数据范围值限制 正向用例：\n针对所有参数，设计1条每个参数的参数值在数据范围内为最大值的正向用例\n逆向用例：\n针对每个参数(假设n个)，设计n条每个参数的参数值都超出数据范围最大值的逆向用例\n针对每个参数(假设n个)，设计n条每个参数的参数值都小于数据范围最小值的逆向用例\n以上几个方面考虑全的话，基本可以做到如下几个方面的覆盖：\n主流程测试用例：正常的主流程功能校验；\n分支流测试用例：正常的分支流功能校验。\n异常流测试用例：异常容错校验\n4) 编写描述 尽量逻辑化，这样方便后续的维护\n5) 实践操作 接口样例\n获取订单列表接口（多条件）\n获取店铺指定期间的所有订单列表(多种条件组合)，默认根据日期倒序排序。\n接口方向\n客户端 -\u0026gt; 服务端\n接口协议\n接口地址：$xxx_Home/xxx/鉴权前缀/xxxxx/getAllOrderList\n接口协议：JSON\nHTTP请求方式：GET\n消息请求\n字段列表如下：\n消息请求样例：\nshopId=1111111111\u0026amp;token=123411nmk515155\u0026amp;queryDate=2015-10-10\n消息响应\n字段元素如下：\n明细列表对象字段元素定义：\n成功时，返回JSON数据包：\n{ \u0026quot;code\u0026quot;: 0, \u0026quot;msg\u0026quot;: \u0026quot;查询订单列表成功！\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;pNo\u0026quot;: 1, \u0026quot;rCount\u0026quot;: 5, \u0026quot;orderTotalPriceTotal\u0026quot;: 23.3, \u0026quot;platformTotalIncomePriceTotal\u0026quot;: 0, \u0026quot;lst\u0026quot;: [ { \u0026quot;orderTitle\u0026quot;: \u0026quot;kouxiangtang\u0026quot;, \u0026quot;settlePrice\u0026quot;: 15.89, \u0026quot;cashTotal\u0026quot;: 15.89, \u0026quot;posTotal\u0026quot;: 0, \u0026quot;onLineTotal\u0026quot;: 0, \u0026quot;orderTime\u0026quot;: \u0026quot;2015-09-29 13:44:26\u0026quot;, \u0026quot;orderId\u0026quot;: \u0026quot;12345679282015092913440268141\u0026quot;, \u0026quot;mobile\u0026quot;: \u0026quot;13424183952\u0026quot; }, { \u0026quot;orderTitle\u0026quot;: \u0026quot;红塔山\u0026quot;, \u0026quot;settlePrice\u0026quot;: 7.5, \u0026quot;cashTotal\u0026quot;: 7.5, \u0026quot;posTotal\u0026quot;: 0, \u0026quot;onLineTotal\u0026quot;: 0, \u0026quot;orderTime\u0026quot;: \u0026quot;2015-09-29 11:37:58\u0026quot;, \u0026quot;orderId\u0026quot;: \u0026quot;12345679282015092911370588273\u0026quot; } ] } }  用例设计 存在问题： 如上，还没写完就有40几条用例了，要是接口参数再多点，接口数量再增加点，工作量可想而知，所以，问题来了，咋办呢？\n个人见解：   根据接口的使用对象(外部，系统内部)，有选择的去、留部分用例\n  根据接口的是否核心接口，有选择的去、留部分用例\n  根据参数说明，及实际情况，有选择的去、留部分用例\n  实例：\n上例这个接口，是供app、商铺后台调用的，且为系统内部调用，所以，以下用例可酌情略去：\ntest-E-按商铺id查询-商铺id非int型 test-E-按设备token查询-token非string类型 test-E-按订单时间类型查询-时间类型非int型 test-E-按起始日期查询-时间类型非date型 test-E-按结束日期查询-时间类型非date型 test-E-按订单状态查询-订单状态非string类型 test-E-按交易状态查询-交易状态非int型 test-E-按支付方式查询-支付方式非int值 test-E-按收银员查询-收银员id非int值 test-E-按导购员查询-导购员id非int值 test-E-按页码查询-页码非int值  理由：\n这个接口是给其它开发于系统内部调用的，开发过程中，开发者肯定需要调用这些接口，如果类型错了，他们也就获取不到预期的数据，这些错误，他们肯定可以发现，所以，他们传递的参数值一般能保证类型正确。\ntest-N-按参数类型最大值查询 所有参数 test-E-按商铺id查询-商铺id超过类型范围值 test-E-按订单状态查询-订单状态值超过类型最大值 test-E-按交易状态查询-交易状态值超过int类型最大值  略去的用例部分（参数值超过类型最大值）\n理由：\n  内部调用，参数值不是外部手动输入的，输入数据长度、值大小可控，当然如果数据一直增长，那再大的类型可能都无法保证不超出，比如自动增长的商铺id\n  部分参数的参数值是自定义的，比如 订单时间类型，就那几种，除非传错了，不然不可能超出范围\n  最后简化后的用例数差不多28条，如果是手工测试，对于正向用例，根据等价类原理，可以制造一条数据，覆盖多条用例，当然，也可以冗余处理，即一条用例一条数据，这样的好处就是每次的验证点比较单一一点，比较有针对性。\n来源\n 火龙果\n","date":"2019-12-25","permalink":"https://www.zxye.tk/posts/test-case-design-intro/","tags":["testing"],"title":"用例设计方法简介"},{"content":"Monkey 是一个在模拟器或设备上运行的程序，可生成伪随机用户事件（例如点击、轻触或手势）流以及很多系统级事件。您可以使用 Monkey 以随机且可重复的方式对正在开发的应用进行压力测试。\n概览 Monkey 是一个命令行工具，可以在任何模拟器实例或设备上运行。它会将伪随机用户事件流发送到系统中，从而在您正在开发的应用软件上进行压力测试。\nMonkey 包含许多选项，主要分为以下四个类别：\n 基本配置选项，例如设置要尝试的事件数。 操作限制条件，例如将测试对象限制为单个软件包。 事件类型和频率。 调试选项。  Monkey 在运行时会生成事件并将其发送到系统。它还会监视被测系统并查找三种特殊情况：\n 如果您已将 Monkey 限制为在一个或多个特定软件包中运行，它会监视转到任何其他软件包的尝试并阻止它们。 如果应用崩溃或收到任何未处理的异常，Monkey 会停止并报告错误。 如果应用生成“应用无响应”错误，Monkey 会停止并报告错误。  根据您选择的详细程度级别，您还将看到有关 Monkey 进度和所生成事件的报告。\nMonkey 的基本用法 您可以使用开发计算机上的命令行启动 Monkey，也可以通过脚本启动。由于 Monkey 在模拟器/设备环境中运行，因此您必须从该环境中通过 shell 启动它。为此，您可以在每个命令前面加上 adb shell，或者直接进入 shell 并输入 Monkey 命令。\n基本语法如下：\n$ adb shell monkey [options] \u0026lt;event-count\u0026gt;  如果未指定任何选项，Monkey 将以静默（非详细）模式启动，并将事件发送到目标上安装的任何（及所有）软件包。下面是一个更典型的命令行，它会启动您的应用并向其发送 500 个伪随机事件：\n$ adb shell monkey -p your.package.name -v 500   命令选项参考 下表列出了您可以在 Monkey 命令行中添加的所有选项。\n   类别 选项 说明     常规 --help 输出简单的使用指南。   -v 命令行上的每个 -v 都会增加详细程度级别。级别 0（默认值）只提供启动通知、测试完成和最终结果。级别 1 提供有关测试在运行时（例如发送到您的 Activity 的各个事件）的更多详细信息。级别 2 提供更详细的设置信息，例如已选择或未选择用于测试的 Activity。    事件 -s  伪随机数生成器的种子值。如果您使用相同的种子值重新运行 Monkey，它将会生成相同的事件序列。    --throttle  在事件之间插入固定的延迟时间。您可以使用此选项减慢 Monkey 速度。如果未指定，则没有延迟，系统会尽快地生成事件。    --pct-touch  调整轻触事件所占百分比。（轻触事件是指屏幕上的单个位置上的按下/释放事件。）    --pct-motion  调整动作事件所占百分比。（动作事件包括屏幕上某个位置的按下事件，一系列伪随机动作和一个释放事件。）    --pct-trackball  调整轨迹球事件所占百分比。（轨迹球事件包括一个或多个随机动作，有时后跟点击。）    --pct-nav  调整“基本”导航事件所占百分比。（导航事件包括向上/向下/向左/向右，作为方向输入设备的输入。）    --pct-majornav  调整“主要”导航事件所占百分比。（这些导航事件通常会导致界面中的操作，例如 5 方向键的中间按钮、返回键或菜单键。）    --pct-syskeys  调整“系统”按键事件所占百分比。（这些按键通常预留供系统使用，例如“主屏幕”、“返回”、“发起通话”、“结束通话”或“音量控件”。）    --pct-appswitch  调整 Activity 启动次数所占百分比。Monkey 会以随机间隔发起 startActivity() 调用，以最大限度地覆盖软件包中的所有 Activity。    --pct-anyevent  调整其他类型事件所占百分比。这包括所有其他类型的事件，例如按键、设备上的其他不太常用的按钮等等。   约束 -p  如果您通过这种方式指定一个或多个软件包，Monkey 将仅允许系统访问这些软件包内的 Activity。如果应用需要访问其他软件包中的 Activity（例如选择联系人），您还需要指定这些软件包。如果您未指定任何软件包，Monkey 将允许系统启动所有软件包中的 Activity。要指定多个软件包，请多次使用 -p 选项 - 每个软件包对应一个 -p 选项。    -c  如果您通过这种方式指定一个或多个类别，Monkey 将仅允许系统访问其中一个指定类别中所列的 Activity。如果您没有指定任何类别，Monkey 会选择 Intent.CATEGORY_LAUNCHER 或 Intent.CATEGORY_MONKEY 类别所列的 Activity。要指定多个类别，请多次使用 -c 选项 - 每个类别对应一个 -c 选项。   调试 --dbg-no-events 指定后，Monkey 将初始启动到测试 Activity，但不会生成任何其他事件。为了获得最佳结果，请结合使用 -v、一个或多个软件包约束条件以及非零限制，以使 Monkey 运行 30 秒或更长时间。这提供了一个环境，您可以在其中监控应用调用的软件包转换操作。    --hprof 如果设置此选项，此选项将在 Monkey 事件序列之前和之后立即生成分析报告。这将在 data/misc 下生成大型（约为 5Mb）文件，因此请谨慎使用。要了解如何分析性能分析报告，请参阅分析应用性能。    --ignore-crashes 通常，当应用崩溃或遇到任何类型的未处理异常时，Monkey 将会停止。如果您指定此选项，Monkey 会继续向系统发送事件，直到计数完成为止。    --ignore-timeouts 通常情况下，如果应用遇到任何类型的超时错误（例如“应用无响应”对话框），Monkey 将会停止。如果您指定此选项，Monkey 会继续向系统发送事件，直到计数完成为止。    --ignore-security-exceptions 通常情况下，如果应用遇到任何类型的权限错误（例如，如果它尝试启动需要特定权限的 Activity），Monkey 将会停止。如果您指定此选项，Monkey 会继续向系统发送事件，直到计数完成为止。    --kill-process-after-error 通常情况下，当 Monkey 因出错而停止运行时，出现故障的应用将保持运行状态。设置此选项后，它将会指示系统停止发生错误的进程。注意，在正常（成功）完成情况下，已启动的进程不会停止，并且设备仅会处于最终事件之后的最后状态。    --monitor-native-crashes 监视并报告 Android 系统原生代码中发生的崩溃。如果设置了 \u0026ndash;kill-process-after-error，系统将会停止。    --wait-dbg 阻止 Monkey 执行，直到为其连接了调试程序。    来源\n UI/Application Exerciser Monkey\n","date":"2019-12-23","permalink":"https://www.zxye.tk/posts/android-adb-shell-monkey-abc/","tags":["android","monkey"],"title":"Android随机测试工具Monkey简介"},{"content":"自动化测试 一般是指软件测试的自动化，软件测试就是在预设条件下运行系统或应用程序，评估运行结果，预先条件应包括正常条件和异常条件。自动化测试是把以人为驱动的测试行为转化为机器执行的一种过程。\n进阶图谱 新手入门 任职要求  有良好的沟通和协调能力，理解能力、逻辑分析能力，有责任心和团队合作精神； 熟练掌握javascript工具； 掌握一种以上自动化测试工具； 熟悉掌握计算机语言，如：C/C++/C#，Java，JS等。  任职标准  参与日常项目测试，编写测试用例，执行测试，确保项目质量和进度； 追踪项目Bug修改情况，注意寻求解决问题方法； 编写自动化测试脚本，主动寻求任何提高测试效率的方法； 主动提供反馈和优化建议，持续改进项目质量； 参与项目性能测试和安全测试； 熟悉web端和移动端的自动化测试流程、方法； 熟练使用常用的自动化测试工具,具备独立完成并维护测试脚本的编写能力。  初级选手 任职要求  熟悉Java，Eclipse, IDEA等开发环境； 了解一种以上自动化测试框架如Selenium/Appium/Uiautomator/Uiautomation/Robotium。  任职标准  根据测试用例创建并提交测试脚本； 关注测试结果并及时更新测试脚本； 维护并更新测试框架及工具； 维护CI和测试环境。   高级专家 任职要求  移动客户端产品测试工作经验（Android，iOS）； 熟悉常用各种测试工具，如：用例管理工具，bug管理工具，性能工具； 熟悉SQL语言以及MySQL数据库操作； 掌握Java编程； 有基于Selenium的自动化测试框架开发经验； 有性能测试经验，掌握Loadrunner工具； 有接口自动化脚本开发经验； 熟练使用linux，能独立完成各类搭建部署工作； 熟悉Oracle或MySQL等数据库； 善于发现、分析和总结问题，富有团队精神，责任心强，能适应高强度的工作。  任职标准  负责移动客户端应用的功能完整性测试，界面用户体验测试，兼容性测试； 参与产品分析过程，根据产品需求创建和维护测试用例，能够制定测试计划； 分析并预警项目风险，规范测试流程和相关制度； 完成测试用例的编写，用例执行，测试报告汇总等日常测试工作，确保产品发布质量。  资深达人 任职要求  熟悉WEB技术，如DOM,HTML/Css,JavaScript； 熟练使用至少一种语言,如：Java、Python、PHP、Perl、Ruby等； 熟悉Oracle/MySQL/SQL Server等至少一种数据库管理系统，能够熟练编写SQL语句； 熟悉常见的性能测试工具或自动化测试工具,并具备测试数据的分析能力； 熟悉基于 Linux 的开发环境，可以自己开发搭建自动化测试工具有效管理自动化脚本的开发和维护工作； 能根据业务特点选型合适的框架，有工具开发或框架经验。  任职标准  能够负责项目的测试工作，依据公司制定的测试工作规范，组织并保证产品质量以及测试工作的顺利进行； 参加并完成项目的测试工作，包括功能测试和自动化测试，其主要会更多职责担当应用系统的自动化测试工作； 开发自动化测试框架，提高测试用例的自动化程度； 研究和实施先进的测试框架和测试方法，提高测试效率； 制定自动化测试计划，撰写测试文档和测试报告，保证测试质量； 协调开发与运维进度，推动项目上线； 对测试工程师进行自动化测试方面的培训岗位要求。  提高ROI 想要提高ROI（Return On Investment，投资回报率），我们必须从两方面入手：\n 减少投入成本。 增加使用率。  针对“减少投入成本” 我们需要做到：\n **减少工具开发的成本。**尽可能的减少开发工具的时间、工具维护的时间，尽可能使用公司已有的，或是业界成熟的工具或组件。 **减少用例录入成本。**简化测试用例录入的成本，尽可能多的提示，如果可以，开发一些批量生成测试用例的工具。 **减少用例维护成本。**减少用例维护成本，尽量只用在页面上做简单的输入即可完成维护动作，而不是进行大量的代码操作。 **减少用例优化成本。**当团队做用例优化时，可以通过一些统计数据，进行有针对性、有目的性的用例优化。  针对“增加使用率” 我们需要做到：\n **手工也能用。**不只是进行接口自动化测试，也可以完全用在手工测试上。 **人人能用。**每一个需要使用测试的人，包括一些非技术人员都可以使用。 **当工具用。**将一些接口用例当成工具使用，比如“生成订单”工具，“查找表单数据”工具。 **每天测试。**进行每日构建测试。 **开发的在构建之后也能触发测试。**开发将被测系统构建后，能自动触发接口自动化测试脚本，进行测试。  用例设计 通用  简单、方便  用例数据与脚本分离，简单、方便。 免去上传脚本的动作，能避免很多不必要的错误和维护时间。 便于维护。   模板化  抽象出通用的模板，可快速拓展。 数据结构一致，便于批量操作。 专人维护、减少多团队间的重复开发工作。 由于使用了统一的模板，那各组之间便可交流、学习、做有效的对比分析。 如果以后这个平台不再使用，或者有更好的平台，可快速迁移。   可统计、可拓展  可统计、可开发工具；如：用例数统计，某服务下有多少条用例等。 可开发用例维护工具。 可开发批量生成工具。    校验 在写自动化脚本的时候，都会想“细致”，然后“写很多”的检查点；但当“校验点”多的时候，又会因为很多原因造成执行失败。所以我们的设计，需要在保证充足的检查点的情况下，还要尽可能减少误报。\n 充足的检查点  可以检查出被测服务更多的缺陷。   尽量少的误报  可以减少很多的人工检查和维护的时间人力成本。   还要  简单、易读。 最好使用一些公式就能实现自己想要的验证。 通用、灵活、多样。 甚至可以用在其他项目的检查上，减少学习成本。    健壮 执行测试的过程中，难免会报失败，执行失败可能的原因有很多，简单分为4类：\n  被测系统出错，这部分其实是我们希望看到的，因为这说明我们的自动化测试真正地发现了一个Bug，用例发挥了它的价值，所以，这是我们希望看到的。 测试工具出错，这部分其实是我们不希望看到的，因为很大可能我们今天的自动化相当于白跑了。 测试数据错误，这是我们要避免的，既然数据容易失效，那我在设计测试平台的时候，就需要考虑如果将所有的数据跑“活”，而不是只写“死”。 不可抗力，这部分是我们也很无奈的，但是这样的情况很少发生。  那针对上面的情况：\n 参数数据失效  支持实时去数据库查询。 支持批量查。   IP进场发生变更  自动更新IP。   灵活、可复用  支持批量维护。 接口测试执行前生成一些数据。 接口执行完成后销毁一些数据。 支持参数使用另一条测试用例的返回结果。 支持一些请求参数实时生成，如token等数据，从而减少数据失效的问题。    通过这些手段，提高测试用例的健壮性，让每一条自动化测试用例都能很好的完成测试任务，真正发挥出一条测试用例的价值。\n易用  简单  功能强大，但要人人会用。 非技术人员也要会用。   减少代码操作  让自动化开发人员注意力能更多的放在用例本身，而不是浪费在无关紧要的开发工作上面。   还要  配置能复用。 通用、易学。 一些数据能自动生成。    参考\n  w3cschool自动化测试 美团接口自动化测试实践  ","date":"2019-12-18","permalink":"https://www.zxye.tk/posts/autotest-abc-and-case-suggest/","tags":["testing","autotest"],"title":"自动化测试入门级用例编写建议"},{"content":"标准号：GB/T 15532-2008 计算机软件测试规范\n关联标准\n GB/T 8566 信息技术 软件生存周期过程\nGB/T 9386 计算机软件测试文档编制规范\nGB/T 11457 信息技术 软件工程术语\nGB/T 16260.1 软件工程 产品质量 第一部分：质量模型\nGB/T 18492 信息技术 系统及软件完整性级别\nGB/T 20158 信息技术 软件生存周期过程 配置管理\n 测试目的 计算机软件的测试目的是：\n 验证软件是否满足软件开发合同或项目开发计划、系统/子系统设计文档、软件需求规格说明、软件设计说明和软件产品说明等规定的软件质量要求； 通过测试，发现软件缺陷； 为软件产品的质量测量和评价提供依据。  测试类别 根据 GB/T 8566 的要求，本标准对如下测试类别做详细描述：\n 单元测试； 集成测试； 配置项测试（也称软件合格性测试或确认测试）； 系统测试； 验收测试。  可根据软件的模型、类型、完整性级别选择执行测试类型。\n回归测试可出现在上述每个测试类别中，并贯穿于整个软件生存周期，故单独分类进行描述。\n测试过程 概述 软件测试过程一般包括四项活动，按顺序分别是：测试侧或、测试设计、测试执行、测试总结。\n测试策划 测试策划主要是进行测试需求分析。即确定需要测试的内容或质量特性；确定测试的充分性要求；踢出测试的基本方法；确定测试的资源和技术需求；进行风险分析与评估；制定测试计划（含资源计划和进度计划）。有关测试计划的内容和要求见 GB/T 9386 。\n测试设计 依据测试需求，分析并选用已有的测试用例或设计新的测试用例；获取并验证测试数据；根据测试资源、风险等约束条件，确定测试用例执行顺序；获取测试资源，开发测试软件；建立并校准测试环境；进行测试就绪评审，主要评审测试计划的合理性和测试用例的正确性、有效性和覆盖充分性，评审测试组织、环境和设备工具是否齐备并符合要求。在进入下一阶段工作之前，应通过测试就绪评审。\n 测试执行 执行测试用例，获取测试结果；分析并制定测试结果。同时根据不同的判定结果采取相应的措施；对测试过程的正常或异常终止情况进行核对，并分局核对结果，对未达到测试终止条件的测试用例，决定是停止测试，还是需要修改或补充测试用例集，并进一步测试。\n测试总结 整理和分析测试数据，评价测试效果和被测软件项，描述测试状态。如，实际测试与测试计划和测试说明的差异、测试充分性分析、未能解决的测试时间等；描述北侧软件项的状态，如，被测软件与需求的差异，发现的软件差错等；最后，完成软件测试报告，并通过测试评审。\n测试方法 静态测试方法 静态测试方法包括检查单和静态分析方法，对文档的静态测试方法主要以检查单的形式进行，而对代码的静态测试方法一般采用代码审查、代码走查和静态分析，静态分析一般包括控制流分析、数据流分析、接口分析和表达式分析。\n应对软件代码进行审查、走查或静态分析；对于规模较小、安全性要求很高的代码也可进行形式化证明。\n动态测试方法 动态测试方法一般采用白盒测试方法和黑盒测试方法。黑盒测试方法一般包裹功能分解、边界值分析、判定表、因果图、状态图、随机测试、猜错法和正交实验法等；白盒测试方法一般包括控制流测试（语句覆盖测试、分支覆盖测试、条件覆盖测试、条件组合覆盖测试、路径覆盖测试）、数据流测试、程序变异、程序插桩、域测试和符号求值等。\n在软件动态测试过程中，采用适当的测试方法，实现测试目标。配置项测试和系统测试一般采用黑盒测试方法；集成测试一般主要采用黑盒测试方法，辅助以白盒测试方法；单元测试一般采用白盒测试方法，辅助以黑盒测试方法。\n静态测试和动态测试的详细说明参加附录 A。\n概述 动态测试是建立在程序的执行过程中。根据被测对象内部情况的了解与否，分为黑盒测试和白盒测试。\n黑盒测试又称功能测试、数据驱动测试或基于规格说明的测试，这种测试不必了解被测对象的内部情况，而依靠需求规格说明中的功能来设计测试用例。\n白盒测试又称结构测试、逻辑测试或基于程序的测试，这种测试应了解程序的内部构造，并根据内部构造设计测试用例。\n在单元测试时一般采用白盒测试，在配置项测试或系统测试时一般采用黑盒测试。\n黑盒测试方法 功能分解 功能分解是将需求规格说明中每一个功能加以分解，确保各个功能被全面地测试。功能分解是一种较常用的方法。\n步骤如下：\n 使用程序设计中的功能抽象方法把程序分解为功能单元； 使用数据抽象方法产生测试每个功能单元的数据。  功能抽象中程序被看成一种抽象的功能层次，每个层次可标识被测试的功能，层次结构中的某一功能由其下一层功能定义。按照功能层次进行分解，可以得到众多的最低层次的子功能，以这些子功能为对象，进行测试用例设计。\n数据对象中，数据结构可以由抽象数据类型的层次图来描述，每个抽象数据类型有其取值集合。程序的每一个输入和输出量的取值集合用数据对象来描述。\n等价类划分 等价类划分是在分析需求规格说明的基础上，吧程序的输入域划分成若干部分，然后在每部分中选取代表性数据形成测试用例。\n步骤如下：\n 划分有效等价类：对规格说明是有意义、合理的输入数据所构成的集合； 划分无效等价类：对规格说明是无意义、不合理的输入数据所构成的集合； 为每个等价类定义一个唯一的编号； 为每一个等价类设计一组测试用例，确保覆盖相应的等价类。  边界值分析 边界值分析是针对边界值进行测试的。使用等于、小于或大于边界值的数据对程序进行测试的方法就是边界值分析方法。\n步骤如下：\n 通过分析规格说明，找出所有可能的边界条件； 对每一个边界条件，给出满足和不满足边界值的输入数据； 设计相应的测试用例。  对满足边界值的输入可以发现计算差错，对不满足的输入可以发现域差错。该方法会为其他测试方法补充一些测试用例，绝大多数测试都会用到本方法。\n判定表 判定表由四部分组成：条件桩、条件条目、动作桩、动作条目。任何一个条件组合的取值及其相应要执行的操作构成规则，条目中的每一列是一条规则。\n条件引用输入的等价类，动作引用被测软件的主要功能处理部分，规则就是测试用例。\n建立并优化判定表，把判定表中每一列表表示的情况写成测试用例。\n该方法的使用有以下要求：\n 规格说明以判定表形式给出，或是很容易转换成判定表； 条件的排列顺序不会影响执行哪些操作； 桂策的排列顺序不会影响执行哪些操作； 每当某一规则的条件已经满足，并确定要执行的操作后，不必检验别的规则； 如果某一规则得到满足，将执行多个操作，这些操作的执行与顺序无关。  因果图 因果图方法是通过画因果图，把用自然语言描述的功能说明转换为判定表，然后为判定表的每一列设计一个测试用例。\n步骤如下：\n 分析程序规格说明，引出原因（输入条件）和结果（输出结果），并给每一个原因和结果赋予一个标识符； 分析程序规格说明中语义的内容，并将其表示成连接各个原因和各个结果的“因果图”； 在因果图上标明约束条件； 通过跟踪因果图中的状态条件，把因果图转换成有限项的判定表； 把判定表中每一列表示的情况生成测试用例。  如果需求规格说明中含有输入条件的组合，宜采用本方法。有些软件的因果图可能非常庞大，以至于根据因果图得到的测试用例数目非常大，此时不宜使用本方法。\n随机测试 随机测试指测试输入数据是所有可能输入值中随机选取的。测试人员只需要规定输入变量的取值区间，在需要时提供必要的变换机制，使产生的随机数服从预期的概率分布。该方法获得预期输出比较困难，多用于可靠性测试和系统强度测试。\n猜错法 猜错法是有经验的测试人员，通过列出可能有的差错和易错情况表，写出测试用例的方法。\n正交实验法 正交实验法是从大量的实验点中挑出适量的、有代表性的点，应用正交表，合理地安排实验的一种科学的实验设计方法。\n利用正交实验法来设计测试用例时，首先要根据被测软件的规格说明书找出影响功能实现的操作对象和外部因素，把它们当做因子，而把各个因子的取值当做状态，生成二元的因素分析表。然后，利用正交表进行各因子的状态组合，构造有效的测试数据集，并由此建立因果图。这样得出的测试用例的数目将大大减少。\n白盒测试方法 控制流测试 控制流测试依据控制流程图产生测试用例，通过对不同控制结构成分的测试验证程序的控制结构。所谓验证某种控制结构即指使这种控制结构在程序运行中得到执行，也称这一过程为覆盖。以下介绍几种覆盖：\n 语句覆盖：要求设计适当数量的测试用例，运行被测程序，使得程序中每一条语句至少被执行一次，语句覆盖在测试中主要发现出错语句。 分支覆盖：要求设计适当数量的测试用例，运行被测程序，使得程序中每个真值分支和假值分支至少执行一次，分支覆盖也称判定覆盖。 条件覆盖：要求设计适当数量的测试用例，运行被测程序，使得每个判断中的每个条件的可能取值至少满足一次。 条件组合覆盖：要求设计适当数量的测试用例，运行被测程序，使得每个判断中条件的各种组合至少出现一次，这种方法包含了“分支覆盖”和“条件覆盖”的各种要求。 路径覆盖：要求设计适当数量的测试用例，运行被测程序，使得程序沿所有可能的路径执行，较大程序的路径可能很多，所以在设计测试用例时，要简化循环次数。  以上各种覆盖的控制流测试步骤如下：\n 将程序流程图转换成控制流图； 经过语法分析求得路径表达式； 生成路径树； 进行路径编码； 经过译码得到执行的路径； 通过路径枚举产生特定路径的测试用例。  数据流测试 数据流测试是用控制流程图对变量的定义和引用进行分析，查找出未定义的变量或定义了未使用的变量，这些变量可能是拼错的变量、变量混淆或丢失了语句。数据流测试一般使用工具进行。\n数据流测试通过一定的覆盖准则，检查程序中每个数据对象的每次定义、使用和消除的情况。\n数据流测试步骤：\n 将程序流程图转换成控制流图； 在每个链路上标注对有关变量的数据操作的操作符号和符号序列； 选定数据流测试策略； 根据测试策略得到测试路径； 根据路径可以获得测试输入数据和测试用例。 动态数据流异常检查在程序运行时执行，获得的是对数据对象的真实操作序列，克服了静态分析检查的局限，但动态方式检查是沿着与测试输入有关的一部分路径进行的，检查的全面性和程序结构覆盖有关。  程序变异 一种差错驱动测试，是为了查出被测软件在做过其他测试后还剩余一些的小差错。本方法一般测试工具进行。\n程序插桩 程序插桩是向被测程序中插入操作以实现测试目的的方法。程序插桩不应该影响到被测程序的运行过程和功能。\n有很多的工具有程序插桩功能。由于数据记录量大，手工进行较为烦琐。\n域测试 域测试是要判别程序对输入空间的划分是否正确。该方法限制太多，使用不方便，供有特殊需求的测试使用。\n符号求值 符号求值是允许数值变量取“符号值”以及数值。符号求值可以检查公式的执行结果是否达到程序预期的目的；也可以通过程序的符号执行，产生出程序的路径，用于产生测试数据。符号求值最好使用工具，在公式分支较少时手工推到也是可行的。\n","date":"2019-12-03","permalink":"https://www.zxye.tk/posts/specification-of-computer-software-testing/","tags":["testing","specification"],"title":"计算机软件测试规范"},{"content":"议题驱动 《麦肯锡教我的思考武器——从逻辑思考到真正解决问题》\n思考，不要用蛮力！工作，不只靠体力！\n从议题出发，创造有价值的工作\n 解决问题之前，要先查明问题 提升答案的质量并不够，提升议题的质量更重要 不是知道越多越聪明，而是知道太多会变笨 与其快速做完每一件事，不如删减要做的事 与其计较数字多寡，不如计较到底有没有答案  价值矩阵 交出有价值成果的生产技术价值矩阵议题度有价值的工作解答度败者之路  以价值为导向的组织里只谈功劳不谈苦劳  对于议题度低的问题，无论多么努力拼命地挤出答案，终究也不能提高其价值，只是白忙而已 只靠努力与蛮力，不可能达到右上方有价值的工作区域    background价值矩阵低议题度-高解答度高议题度-高解答度低议题度-低解答度高议题度-低解答度解答度解答度解 \u0026#8203;答 \u0026#8203;度议题度议题度议题度有价值的工作有价值的工作低议题度-低解答度高议题度-高解答度败者之路败者之路败者之路败者之路无法产出有价值的工作高议题度-低解答度查明议题查明议题查明议题推敲解答推敲解答推敲\u0026#8203;解答","date":"2019-09-28","permalink":"https://www.zxye.tk/posts/issue-driven/","tags":["book"],"title":"麦肯锡教我的思考武器"},{"content":"准备工作  一台或多台运行着下列系统的机器:  CentOS 7 RHEL 7   每台机器 2 GB 或更多的 RAM (如果少于这个数字将会影响您应用的运行内存) 2 CPU 核心或更多 集群中的所有机器的网络彼此均能相互连接(公网和内网都可以) 节点之中不可以有重复的主机名，MAC 地址，product_uuid。更多详细信息请参见这里 。 开启主机上的一些特定端口. 更多详细信息请参见这里。 禁用 Swap 交换分区。为了保证 kubelet 正确运行，您 必须 禁用交换分区。  确保每个节点上 MAC 地址和 product_uuid 的唯一性。  您可以使用下列命令获取网络接口的 MAC 地址：ip link 或是 ifconfig -a 下列命令可以用来获取 product_uuid sudo cat /sys/class/dmi/id/product_uuid  一般来讲，硬件设备会拥有独一无二的地址，但是有些虚拟机可能会雷同。Kubernetes 使用这些值来唯一确定集群中的节点。如果这些值在集群中不唯一，可能会导致安装失败。\n检查网络适配器 如果您有一个以上的网络适配器，同时您的 Kubernetes 组件通过默认路由不可达，我们建议您预先添加 IP 路由规则，这样 Kubernetes 集群就可以通过对应的适配器完成连接。\n检查所需端口 Master 节点    规则 方向 端口范围 作用 使用者     TCP Inbound 6443* Kubernetes API server All   TCP Inbound 2379-2380 etcd server client API kube-apiserver, etcd   TCP Inbound 10250 Kubelet API Self, Control plane   TCP Inbound 10251 kube-scheduler Self   TCP Inbound 10252 kube-controller-manager Self    Worker 节点    规则 方向 端口范围 作用 使用者     TCP Inbound 10250 Kubelet API Self, Control plane   TCP Inbound 30000-32767 NodePort Services** All    ** NodePort 服务 的默认端口范围。\n任何使用 * 标记的端口号都有可能被覆盖，所以您需要保证您的自定义端口的状态是开放的。\n虽然主节点已经包含了 etcd 的端口，您也可以使用自定义的外部 etcd 集群，或是指定自定义端口。 您使用的 pod 网络插件 (见下) 也可能需要某些特定端口开启。由于各个 pod 网络插件都有所不同，请参阅他们各自文档中对端口的要求。\n安装 kubeadm, kubelet 和 kubectl 您需要在每台机器上都安装以下的软件包：\n kubeadm: 用来初始化集群的指令。 kubelet: 在集群中的每个节点上用来启动 pod 和 container 等。 kubectl: 用来与集群通信的命令行工具。  kubeadm 不能 帮您安装或管理 kubelet 或 kubectl ，所以您得保证他们满足通过 kubeadm 安装的 Kubernetes 控制层对版本的要求。如果版本没有满足要求，就有可能导致一些难以想到的错误或问题。然而控制层与 kubelet 间的 小版本号 不一致无伤大雅，不过请记住 kubelet 的版本不可以超过 API server 的版本。例如 1.8.0 的 API server 可以适配 1.7.0 的 kubelet，反之就不行了。\ncat \u0026lt;\u0026lt;EOF \u0026gt; /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64 enabled=1 gpgcheck=1 repo_gpgcheck=1 gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg exclude=kube* EOF # 将 SELinux 设置为 permissive 模式(将其禁用) setenforce 0 sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes systemctl enable kubelet \u0026amp;\u0026amp; systemctl start kubelet  请注意：\n- 通过命令 setenforce 0 和 sed ... 可以将 SELinux 设置为 permissive 模式(将其禁用)。 只有执行这一操作之后，容器才能访问宿主的文件系统，进而能够正常使用 Pod 网络。您必须这么做，直到 kubelet 做出升级支持 SELinux 为止。 - 一些 RHEL/CentOS 7 的用户曾经遇到过：由于 iptables 被绕过导致网络请求被错误的路由。您得保证 在您的 sysctl 配置中 net.bridge.bridge-nf-call-iptables 被设为1。\ncat \u0026lt;\u0026lt;EOF \u0026gt; /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sysctl --system  kubelet 现在每隔几秒就会重启，因为它陷入了一个等待 kubeadm 指令的死循环。\n在 Master 节点上配置 kubelet 所需的 cgroup 驱动 使用 Docker 时，kubeadm 会自动为其检测 cgroup 驱动在运行时对 /var/lib/kubelet/kubeadm-flags.env 文件进行配置。 如果您使用了不同的 CRI， 您得把 /etc/default/kubelet 文件中的 cgroup-driver 位置改为对应的值，像这样：\nKUBELET_EXTRA_ARGS=--cgroup-driver=\u0026lt;value\u0026gt;  这个文件将会被 kubeadm init 和 kubeadm join 用于为 kubelet 获取 额外的用户参数。\n请注意，您只需要在您的 cgroup driver 不是 cgroupfs 时这么做，因为 cgroupfs 已经是 kubelet 的默认值了。\n需要重启 kubelet：\nsystemctl daemon-reload systemctl restart kubelet  使用 kubeadm 创建一个单主集群 ","date":"2019-08-02","permalink":"https://www.zxye.tk/posts/kubernetes-cluster-using-centos/","tags":["kubernetes","centos","k8s"],"title":"CentOS 安装 Kubernetes 集群"}]